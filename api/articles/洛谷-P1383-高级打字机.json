{"title":"洛谷-P1383 高级打字机 题解","uid":"0eee92f956429317e7277e463252038c","slug":"洛谷-P1383-高级打字机","date":"2020-05-19T16:23:53.000Z","updated":"2020-05-19T16:23:53.000Z","comments":true,"path":"api/articles/洛谷-P1383-高级打字机.json","keywords":null,"cover":[],"content":"<!-- # 洛谷-P1383 高级打字机 题解 -->\n<p>如果使用 Haskell 语言的话，本题可以使用 <code>containers</code>\n包中的 <code>Data.Sequence</code> 秒杀，因为 <code>Seq</code>\n本身便是一颗可持久的\n<code>FingerTree</code>，用树套树的话，便可以做到一个非常优异的时间/空间复杂度。</p>\n<p>惰性求值但是的确是在线算法，可以撤回撤回（返回撤回前的时间点，不知道算不算）。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">{-# OPTIONS_GHC -O2 #-}</span> <span class=\"comment\">-- 强开O2</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>           Control.Monad</span><br><span class=\"line\"><span class=\"keyword\">import</span>           Data.Functor  (($&gt;))</span><br><span class=\"line\"><span class=\"keyword\">import</span>           Data.Maybe    (<span class=\"title\">fromJust</span>)</span><br><span class=\"line\"><span class=\"keyword\">import</span>           Data.Sequence</span><br><span class=\"line\"><span class=\"keyword\">import</span>           Text.Printf   (<span class=\"title\">printf</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">(!) = index <span class=\"comment\">-- 强行把函数变成运算符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> :: <span class=\"type\">IO</span> ()</span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">    n &lt;- readLn :: <span class=\"type\">IO</span> <span class=\"type\">Int</span> <span class=\"comment\">-- 读取第一行的整数n，需要手动指定类型，不然会有歧义</span></span><br><span class=\"line\">    fromList [fromList []] `foldM_'` [<span class=\"number\">1</span>..n] $ \\seq _ -&gt; <span class=\"keyword\">do</span> <span class=\"comment\">-- 函数的中缀用法，注意初始的历史记录应该有一个空串</span></span><br><span class=\"line\">        [[op],c] &lt;- words &lt;$&gt; getLine <span class=\"comment\">-- 读取每一行的指令，此处使用了模式匹配（见下文）</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> op <span class=\"keyword\">of</span></span><br><span class=\"line\">            <span class=\"string\">'T'</span> -&gt; pure $ (seq!<span class=\"number\">0</span> |&gt; head c) &lt;| seq  <span class=\"comment\">-- 历史记录第0号（即上一次修改的结果）后插入当前字符，然后前插入历史记录</span></span><br><span class=\"line\">            <span class=\"string\">'U'</span> -&gt; pure $ (seq!read c) &lt;| seq <span class=\"comment\">-- 将参数读取为整数（此处无需标明，因为函数有明确的类型限制，编译器将自动推导） 取历史记录的相应项，前插入历史记录</span></span><br><span class=\"line\">            <span class=\"string\">'Q'</span> -&gt; printf <span class=\"string\">\"%c\\n\"</span> (seq!<span class=\"number\">0</span>!(read c-<span class=\"number\">1</span>))  $&gt; seq <span class=\"comment\">-- 将上一次修改的结果的相应位置的字符打印出来，并返回本身的历史记录（($ &gt;)运算符特性）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">foldM_'</span> z l f = foldM_ f z l <span class=\"comment\">-- 调整参数位置，追求好用</span></span><br></pre></td></tr></table></figure>\n<p>代码十分朴素。</p>\n<ul>\n<li>空间复杂度: <span class=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span> ，其中\n<span class=\"math inline\"><em>n</em></span>\n为总字符数（不是很紧确，但是..能过）</li>\n<li>每次从后面添加字符，时间复杂度: <span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>每次打印第 <span class=\"math inline\"><em>i</em></span>\n个字符，时间复杂度: <span class=\"math inline\"><em>O</em>(log (min (<em>i</em>, <em>n</em> − <em>i</em>)))</span>\n，其中 <span class=\"math inline\"><em>n</em></span> 为当前字符数， <span class=\"math inline\"><em>i</em></span> 为需要打印的字符位置。</li>\n<li>每次撤销，时间复杂度: <span class=\"math inline\"><em>O</em>(log (min (<em>i</em>, <em>n</em> − <em>i</em>)))</span>\n，其中 <span class=\"math inline\"><em>n</em></span> 为总修改次数，<span class=\"math inline\"><em>i</em></span> 为撤销步数。</li>\n<li>总时间复杂度可估算为: <span class=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span></li>\n</ul>\n<p>如果想看 <code>FingerTree</code> 原理或者希望以此为契机了解一下\n<code>Haskell</code> 的话参见后文。也可以参考论文原文。</p>\n<p>参考文献：</p>\n<ul>\n<li>Hinze R, Paterson R. Finger trees: a simple general-purpose data\nstructure[J]. Journal of functional programming, 2006, 16(2):\n197-217.</li>\n<li>https://hackage.haskell.org/package/fingertree</li>\n<li>https://hackage.haskell.org/package/container</li>\n<li>https://wiki.haskell.org/Functional_dependencies</li>\n</ul>\n<h2 id=\"fingertree概述\">FingerTree概述</h2>\n<p>说到可持久化，就得想到 Immutable ，说到 Immutable\n，自然而然就是函数式编程语言，说到函数式编程语言，自然而然就是\n<code>Haskell</code> ，而说到纯函数式的数据结构，自然而然也绕不开\n<code>FingerTree</code> 。</p>\n<p><code>FingerTree</code>\n是一种理论上非常通用也非常高效的数据结构，插入头/尾都只需要摊还 <span class=\"math inline\"><em>O</em>(1)</span> 的时间，\n而对其的“随机”访问只需要 <span class=\"math inline\"><em>O</em>(log min (<em>i</em>, <em>n</em> − <em>i</em>))</span>\n&gt; 其中 <span class=\"math inline\"><em>i</em></span>\n为你访问的下标，所以可以看出访问头/尾其实也是 <span class=\"math inline\"><em>O</em>(1)</span> 。</p>\n<p>关于它的论文可以戳<a href=\"https://www.staff.city.ac.uk/~ross/papers/FingerTree.pdf\">这里</a>。当然这不是最早的一篇，但我看的就是这篇，才疏学浅没办法在这里列更早的。</p>\n<p>但为什么说“理论”上呢，就和斐波那契堆类似，他的常数比较大。（<del>主要因素是Immutable的语言必须维护一个GC来做垃圾回收。</del>）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[更新] 事后我拿 <code>Rust</code> 实现了一遍 <code>FingerTree</code>\n，发现其时空消耗均比 <code>Haskell</code> 大，故可认为并非GC原因。</p>\n<p>不过也有可能是我写的常数就是大呢（</p>\n<p>详见：<a href=\"https://www.luogu.com.cn/record/60755672\">提交记录</a></p></blockquote>\n<p>那为什么说“随机”呢？因为完全泛化的 <code>FingerTree</code>\n的访问依赖的不是下标，而是一个被称作 <span class=\"math inline\"><em>M</em><em>e</em><em>a</em><em>s</em><em>u</em><em>r</em><em>e</em></span>\n（测度？我也不知道怎么翻译，所以直接拉的原文）的幺半群\n(<strong>Monoid</strong>)。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>先解释一下什么是幺半群。幺半群是一个集合 <span class=\"math inline\"><em>X</em></span> 和集合里元素之间一个二元运算 <span class=\"math inline\">⋅ : <em>X</em> × <em>X</em> → <em>X</em></span>\n的统称（有序对），并要求：</p>\n<ul>\n<li>二元运算满足结合率，即 <span class=\"math inline\">∀<em>x</em>, <em>y</em>, <em>z</em> ∈ <em>X</em> : (<em>x</em> ⋅ <em>y</em>) ⋅ <em>z</em> = <em>x</em> ⋅ (<em>y</em> ⋅ <em>z</em>)</span></li>\n<li>集合 <span class=\"math inline\"><em>X</em></span>\n中存在一个单位元，即 <span class=\"math inline\">∃<em>e</em> : (∀<em>x</em> : <em>e</em> ⋅ <em>x</em> = <em>x</em> ⋅ <em>e</em> = <em>x</em>)</span></li>\n</ul>\n<p>比如说自然数集 <span class=\"math inline\">ℕ</span> 与其上的加法 <span class=\"math inline\">+</span>\n便可以构成一个幺半群（后面我们可以用这条性质做出传统意义上的下标索引）</p>\n<p>进一步，我们可以定义两个幺半群的笛卡尔积也是一个幺半群，即对于 <span class=\"math inline\">(<em>X</em>, ⋅<sub>1</sub>)</span> 与 <span class=\"math inline\">(<em>Y</em>, ⋅<sub>2</sub>)</span> ，\n我们可以定义一个运算 <span class=\"math inline\">⋅ : (<em>X</em> × <em>Y</em>) × (<em>X</em> × <em>Y</em>) → <em>X</em> × <em>Y</em></span>\n，并使其满足结合率。定义方法如下：</p>\n<ul>\n<li><span class=\"math inline\">(<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) ⋅ (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>) = (<em>x</em><sub>1</sub>⋅<sub>1</sub><em>x</em><sub>2</sub>, <em>y</em><sub>1</sub>⋅<sub>2</sub><em>y</em><sub>2</sub>)</span></li>\n</ul>\n<p>我们可以用这个条件来拓展我们索引方式（比如论文原文里可以看到用 <span class=\"math inline\">max </span> 幺半群实现的最大堆/优先队列）</p></blockquote>\n<h2 id=\"haskell基础\">Haskell基础</h2>\n<p>首先，用 <code>Haskell</code>\n的方式定义一下幺半群（实际上这个标准库有，不需要自己实现）</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">Monoid</span> a <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    mempty :: a</span><br><span class=\"line\">    mappend :: a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>\n<p>与常用的C-like语言中的 <code>class</code> 不同，在\n<code>Haskell</code> 中，这代表一个类型类，是对类型 <code>a</code>\n的一种约束，类似于接口/抽象类一类的概念。</p>\n<p>然后是 <code>Foldable</code> ，它代表我们可以在一个类型(其实是一个\n<code>Kind</code>\n，拿类型生成类型的类型构造子)上按照某种顺序去遍历。类似于\n<code>Java 8</code> 中的 <code>reduce</code>\n。注意这个其实标准库也有，只是提一嘴。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">Foldable</span> f <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b</span><br><span class=\"line\">    foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b</span><br></pre></td></tr></table></figure>\n<p>还需要提一嘴的是 <code>Haskell</code>\n最基本的数据结构，链表(实际上还是单端链表，所以只提供最基本的功能)。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> [] a = [] | a:([] <span class=\"title\">a</span>)</span></span><br></pre></td></tr></table></figure>\n<p>它意味着一个 <span class=\"math inline\"><em>a</em></span>\n类型的链表有两种构造方式，一种是空链表，令一种是一个 <span class=\"math inline\"><em>a</em></span> 类型的元素用 <code>:</code>\n运算符拼接一个 <span class=\"math inline\"><em>a</em></span>\n类型的链表。（对，中缀构造函数， <code>C++</code> 是做不到这点的。）</p>\n<p>另外还有一个比较常用的 <code>data</code> 被称作 <code>Maybe</code>\n，它的定义等价于：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">Maybe</span> a = <span class=\"type\">Nothing</span> | <span class=\"type\">Just</span> a</span></span><br></pre></td></tr></table></figure>\n<p>想一想，这个定义是什么意思？</p>\n<p>从这里开始就可以看到 <code>Haskell</code>\n的一些特性了。<code>Haskell</code>\n中的数据结构并非由<em>字段</em>和<em>操作</em>构成，而是由几类数据的组合组合而成。当然它是可以实现上面的俩\n<code>class</code> 的。这里我不做过多介绍。</p>\n<h2 id=\"fingertree-实现简要复述论文\">FingerTree\n实现（简要复述论文）</h2>\n<figure>\n<img src=\"https://www.staff.city.ac.uk/~ross/papers/FingerTree/example-tree.svg\" alt=\"FingerTree 概要图\">\n<figcaption aria-hidden=\"true\">FingerTree 概要图</figcaption>\n</figure>\n<p>首先是一些基础定义。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- | Things that can be measured.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> (<span class=\"type\">Monoid</span> <span class=\"title\">v</span>) =&gt; <span class=\"type\">Measured</span> v a | a -&gt; v <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    measure :: a -&gt; v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">Node</span> v a = <span class=\"type\">Node2</span> v a a | <span class=\"type\">Node3</span> v a a a</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">Digit</span> a</span></span><br><span class=\"line\">    = <span class=\"type\">One</span> a</span><br><span class=\"line\">    | <span class=\"type\">Two</span> a a</span><br><span class=\"line\">    | <span class=\"type\">Three</span> a a a</span><br><span class=\"line\">    | <span class=\"type\">Four</span> a a a a</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">FingerTree</span> v a</span></span><br><span class=\"line\">     = <span class=\"type\">Empty</span></span><br><span class=\"line\">     | <span class=\"type\">Single</span> a</span><br><span class=\"line\">     | <span class=\"type\">Deep</span> v (<span class=\"type\">Digit</span> a) (<span class=\"type\">FingerTree</span> v (<span class=\"type\">Node</span> v a)) (<span class=\"type\">Digit</span> a)</span><br></pre></td></tr></table></figure>\n<p>这里开始出现了最开始提到的\n<code>Measured</code>，此处将其抽象为一个可以将某个元素<em>测量</em>出一个\n<code>Monoid</code> 的函数。但这个 <code>Monoid</code> 有大用。</p>\n<p>此处出现的语法使用了一个 <code>Functional Dependencies</code>\n的拓展(可参见 <a href=\"https://wiki.haskell.org/Functional_dependencies\">wiki</a>\n)。大概意思是保证对于一个类型，我只能把它 <code>measure</code>\n成一种其他类型，不能 <code>measure</code> 成另一种。也就是说，类型\n<code>a</code> 到类型 <code>v</code> 是一个单射。</p>\n<p>可以看到这里的 <span class=\"math inline\"><em>v</em></span>\n类型变元，这个就是稍后要维护的\n<code>Monoid</code>，也是索引数据的依据。</p>\n<p>可以看到一个 <code>Node</code> 可能有2-3个元素，保证一个\n<code>Digit</code> 有 1-4\n个元素。(图中也可以看出，不过引用链接是国外的可能比较卡)\n<code>Digit</code> 和 <code>Node</code>\n也可以相互转化，拼接，但后文不再说明实现。</p>\n<p>还有一点值得注意的是，如果当前这一层的 <code>FingerTree</code>\n缓存的是 <code>a</code> 类型的话，那么下一层所缓存的就是\n<code>Node a</code> 类型了。这也就意味着，下层比上层“厚实”。</p>\n<p>自然地，我们可以给 <code>Node</code> 和 <code>Digit</code> 来个\n<code>Foldable</code>，但具体部分就不展示了。</p>\n<p>那么我们应该如何方便的维护这个 <span class=\"math inline\"><em>v</em></span>\n类型的数据呢，答案是换一种方式重写构造函数。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">deep</span> ::  (<span class=\"type\">Measured</span> v a) =&gt;</span><br><span class=\"line\">      <span class=\"type\">Digit</span> a -&gt; <span class=\"type\">FingerTree</span> v (<span class=\"type\">Node</span> v a) -&gt; <span class=\"type\">Digit</span> a -&gt; <span class=\"type\">FingerTree</span> v a</span><br><span class=\"line\"> deep pr m sf = <span class=\"type\">Deep</span> ((measure pr `mappend` measure m) `mappend` measure sf) pr m sf</span><br></pre></td></tr></table></figure>\n<p>此处的 <code>mappend</code> 是 <code>Haskell</code>\n里函数的中缀用法（就是把函数当运算符用）。</p>\n<p>此时，我们不需要每次构造树的时候手动维护 <span class=\"math inline\"><em>v</em></span> 类型的数据了，只需要简单把\n<code>Deep</code> 替换为 <code>deep</code> 即可。</p>\n<p>另外，关于 <code>Measured</code> 本身，我们也可以让\n<code>FingerTree</code> 也是 <code>Measured</code>，具体代码如下：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> (<span class=\"type\">Measured</span> <span class=\"title\">v</span> <span class=\"title\">a</span>) =&gt; <span class=\"type\">Measured</span> v (<span class=\"type\">FingerTree</span> <span class=\"title\">v</span> <span class=\"title\">a</span>) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">      measure <span class=\"type\">Empty</span>           =  mempty</span><br><span class=\"line\">      measure (<span class=\"type\">Single</span> x)      =  measure x</span><br><span class=\"line\">      measure (<span class=\"type\">Deep</span> v _ _ _)  =  v</span><br></pre></td></tr></table></figure>\n<p>注意到此处使用了 <code>Haskell</code> 被称作<strong>模式匹配</strong>\n(<strong>Pattern\nMatch</strong>)的特性。（不是模式串匹配啦）把数据结构重新打回了它最开始定义时的样子，并且怎么被构造的就怎么被匹配。(真-打回娘胎)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>模式匹配不止可以匹配一层，也可以匹配多层。至于用途嘛..请自行搜索\nHaskell 的 20 行红黑树。</p></blockquote>\n<p>可以看到对于 <code>Deep</code> 一类，我们直接使用了其缓存的 <span class=\"math inline\"><em>v</em></span> 类型字段，这样就可以在 <span class=\"math inline\"><em>O</em>(1)</span>\n时间内得到一颗子树的测度。(如果对单个元素的 <code>measure</code> 也是\n<span class=\"math inline\"><em>O</em>(1)</span> 的话)</p>\n<p>当然 <code>Node</code> 和 <code>Digit</code> 也可以是\n<code>Measured</code>，具体实现请自行脑补。</p>\n<p>接下来是前插入的定义。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">infixr</span> <span class=\"number\">5</span> &lt;|</span><br><span class=\"line\"><span class=\"comment\">-- | /O(1)/. Add an element to the left end of a sequence.</span></span><br><span class=\"line\"><span class=\"comment\">-- Mnemonic: a triangle with the single element at the pointy end.</span></span><br><span class=\"line\">(&lt;|) :: <span class=\"type\">Measured</span> v a =&gt; a -&gt; <span class=\"type\">FingerTree</span> v a -&gt; <span class=\"type\">FingerTree</span> v a</span><br><span class=\"line\"><span class=\"title\">a</span> &lt;| <span class=\"type\">Empty</span>              =  <span class=\"type\">Single</span> a</span><br><span class=\"line\"><span class=\"title\">a</span> &lt;| <span class=\"type\">Single</span> b           =  deep (<span class=\"type\">One</span> a) <span class=\"type\">Empty</span> (<span class=\"type\">One</span> b)</span><br><span class=\"line\"><span class=\"title\">a</span> &lt;| <span class=\"type\">Deep</span> v (<span class=\"type\">Four</span> b c d e) m sf</span><br><span class=\"line\">    = <span class=\"type\">Deep</span> (measure a `mappend` v) (<span class=\"type\">Two</span> a b) (node3 c d e &lt;| m) sf</span><br><span class=\"line\"><span class=\"title\">a</span> &lt;| <span class=\"type\">Deep</span> v pr m sf     = <span class=\"type\">Deep</span> (measure a `mappend` v) (consDigit a pr) m sf</span><br></pre></td></tr></table></figure>\n<p>注意到这里我们自定义了一个运算符，它的优先级是5,并且是右结合的。（不愧是\n<code>Haskell</code>，轻易做到了 <code>C++</code> 做不到的事情。）</p>\n<p><code>consDigit</code> 就是给 <code>pr</code>\n前插入一个元素。当然，如果是满的肯定会报错，但是在它之前的模式匹配会避免这一点发生。</p>\n<p>类似地还有后插入</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">infixl</span> <span class=\"number\">5</span> .</span><br><span class=\"line\"><span class=\"comment\">-- | /O(1)/. Add an element to the right end of a sequence.</span></span><br><span class=\"line\"><span class=\"comment\">-- Mnemonic: a triangle with the single element at the pointy end.</span></span><br><span class=\"line\">(|&gt;) :: (<span class=\"type\">Measured</span> v a) =&gt; <span class=\"type\">FingerTree</span> v a -&gt; a -&gt; <span class=\"type\">FingerTree</span> v a</span><br><span class=\"line\"><span class=\"type\">Empty</span> |&gt; a              =  <span class=\"type\">Single</span> a</span><br><span class=\"line\"><span class=\"type\">Single</span> a |&gt; b           =  deep (<span class=\"type\">One</span> a) <span class=\"type\">Empty</span> (<span class=\"type\">One</span> b)</span><br><span class=\"line\"><span class=\"type\">Deep</span> v pr m (<span class=\"type\">Four</span> a b c d) |&gt; e</span><br><span class=\"line\">    = <span class=\"type\">Deep</span> (v `mappend` measure e) pr (m |&gt; node3 a b c) (<span class=\"type\">Two</span> d e)</span><br><span class=\"line\"><span class=\"type\">Deep</span> v pr m sf |&gt; x     = <span class=\"type\">Deep</span> (v `mappend` measure x) pr m (snocDigit sf x)</span><br></pre></td></tr></table></figure>\n<p>可以看到代码基本上和前插入是对称的。（数据结构本身也是对称的，所以这里写作\n<code>snocDigit</code>，其中 <code>snoc</code> 正是 <code>cons</code>\n的回文）后面还有很多对称的结构，均以左半部分为例。</p>\n<p>然后是一个分割原语（当然右侧也是对称的，可以看到又出现了运算符构造子。）</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- | View of the left end of a sequence.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">ViewL</span> s a</span></span><br><span class=\"line\">     = <span class=\"type\">EmptyL</span>        <span class=\"comment\">-- ^ empty sequence</span></span><br><span class=\"line\">     | a :&lt; s a      <span class=\"comment\">-- ^ leftmost element and the rest of the sequence</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- | /O(1)/. Analyse the left end of a sequence.</span></span><br><span class=\"line\"><span class=\"title\">viewl</span> :: (<span class=\"type\">Measured</span> v a) =&gt; <span class=\"type\">FingerTree</span> v a -&gt; <span class=\"type\">ViewL</span> (<span class=\"type\">FingerTree</span> v) a</span><br><span class=\"line\"><span class=\"title\">viewl</span> <span class=\"type\">Empty</span>                     =  <span class=\"type\">EmptyL</span></span><br><span class=\"line\"><span class=\"title\">viewl</span> (<span class=\"type\">Single</span> x)                =  x :&lt; <span class=\"type\">Empty</span></span><br><span class=\"line\"><span class=\"title\">viewl</span> (<span class=\"type\">Deep</span> _ (<span class=\"type\">One</span> x) m sf)     =  x :&lt; rotL m sf</span><br><span class=\"line\"><span class=\"title\">viewl</span> (<span class=\"type\">Deep</span> _ pr m sf)          =  lheadDigit pr :&lt; deep (ltailDigit pr) m sf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">rotL</span> :: (<span class=\"type\">Measured</span> v a) =&gt; <span class=\"type\">FingerTree</span> v (<span class=\"type\">Node</span> v a) -&gt; <span class=\"type\">Digit</span> a -&gt; <span class=\"type\">FingerTree</span> v a</span><br><span class=\"line\"><span class=\"title\">rotL</span> m sf      =   <span class=\"keyword\">case</span> viewl m <span class=\"keyword\">of</span></span><br><span class=\"line\">    <span class=\"type\">EmptyL</span>  -&gt;  digitToTree sf</span><br><span class=\"line\">    a :&lt; m' -&gt;  <span class=\"type\">Deep</span> (measure m `mappend` measure sf) (nodeToDigit a) m' sf</span><br></pre></td></tr></table></figure>\n<p><code>lheadDigit</code> 和 <code>ltailDigit</code> 是指一个\n<code>Digit</code> 的最左边元素和剩下的元素，当然如果 <code>Digit</code>\n只有一个元素的画 <code>ltail</code>\n就会报错，但是前面的模式匹配也避免了这一点。</p>\n<p><code>digitToTree</code> 是一个将 <code>Digit</code> 变为一个\n<code>FingerTree</code> 的函数，因为也就常数个元素，所以时间复杂度 <span class=\"math inline\"><em>O</em>(1)</span>。</p>\n<p><code>nodeToDigit</code> 也是跟名字异样，将一个\n<code>Node</code>(2或3个元素)变成一个 <code>Digit</code>。</p>\n<p><code>case ... of</code> 语法是 <code>Haskell</code> 类似于\n<code>C++</code> 的 <code>switch</code>\n语句的地方。不同之处在于其是有返回值的，更像一个多出口的 <code>?:</code>\n运算符。</p>\n<p><code>viewl</code>\n函数构造一颗树的左分割，将其切割出最左元素（若没有则用\n<code>EmptyL</code> 构造子）。</p>\n<p>另外值得注意的是此处的 <code>viewl</code> 和 <code>rotL</code>\n是互相调用，也是一种递归哦。</p>\n<p>当然其有对称实现 <code>viewr</code>。但不在此赘述。</p>\n<p>有了 <code>viewl</code> 之后，我们就可以处理一些 <code>prefix</code>\n(即 <code>Deep</code> 中第一个\n<code>Digit</code>)为空/不存在时对树的构造了</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">deepL</span> :: (<span class=\"type\">Measured</span> v a) =&gt;</span><br><span class=\"line\">    <span class=\"type\">Maybe</span> (<span class=\"type\">Digit</span> a) -&gt; <span class=\"type\">FingerTree</span> v (<span class=\"type\">Node</span> v a) -&gt; <span class=\"type\">Digit</span> a -&gt; <span class=\"type\">FingerTree</span> v a</span><br><span class=\"line\"><span class=\"title\">deepL</span> <span class=\"type\">Nothing</span> m sf      =   rotL m sf</span><br><span class=\"line\"><span class=\"title\">deepL</span> (<span class=\"type\">Just</span> pr) m sf    =   deep pr m sf</span><br></pre></td></tr></table></figure>\n<p>此处的 <code>Nothing</code> 就是指 <code>prefix</code>\n不存在的情况，此时需要<em>左旋</em>一波。</p>\n<p>当然对于 <code>Just</code> 的情况就直接调用上面的deep了。</p>\n<p>那么什么情况下左边/右边为空呢？当然是做分割的时候了。</p>\n<p>那么终于，要迎来最后的部分了，搜索，与分割。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">Split</span> t a = <span class=\"type\">Split</span> t a t</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">SearchResult</span> v a</span></span><br><span class=\"line\">    = <span class=\"type\">Position</span> (<span class=\"type\">FingerTree</span> v a) a (<span class=\"type\">FingerTree</span> v a)</span><br><span class=\"line\">        <span class=\"comment\">-- ^ A tree opened at a particular element: the prefix to the</span></span><br><span class=\"line\">       <span class=\"comment\">-- left, the element, and the suffix to the right.</span></span><br><span class=\"line\">   | <span class=\"type\">OnLeft</span></span><br><span class=\"line\">       <span class=\"comment\">-- ^ A position to the left of the sequence, indicating that the</span></span><br><span class=\"line\">       <span class=\"comment\">-- predicate is 'True' at both ends.</span></span><br><span class=\"line\">   | <span class=\"type\">OnRight</span></span><br><span class=\"line\">       <span class=\"comment\">-- ^ A position to the right of the sequence, indicating that the</span></span><br><span class=\"line\">       <span class=\"comment\">-- predicate is 'False' at both ends.</span></span><br><span class=\"line\">   | <span class=\"type\">Nowhere</span></span><br><span class=\"line\">       <span class=\"comment\">-- ^ No position in the tree, returned if the predicate is 'True'</span></span><br><span class=\"line\">       <span class=\"comment\">-- at the left end and 'False' at the right end.  This will not</span></span><br><span class=\"line\">       <span class=\"comment\">-- occur if the predicate in monotonic on the tree.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">search</span> :: (<span class=\"type\">Measured</span> v a) =&gt;</span><br><span class=\"line\">    (v -&gt; v -&gt; <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">FingerTree</span> v a -&gt; <span class=\"type\">SearchResult</span> v a</span><br><span class=\"line\"><span class=\"title\">search</span> p t</span><br><span class=\"line\">  | p_left &amp;&amp; p_right = <span class=\"type\">OnLeft</span></span><br><span class=\"line\">  | not p_left &amp;&amp; p_right = <span class=\"keyword\">case</span> searchTree p mempty t mempty <span class=\"keyword\">of</span></span><br><span class=\"line\">         <span class=\"type\">Split</span> l x r -&gt; <span class=\"type\">Position</span> l x r</span><br><span class=\"line\">  | not p_left &amp;&amp; not p_right = <span class=\"type\">OnRight</span></span><br><span class=\"line\">  | otherwise = <span class=\"type\">Nowhere</span></span><br><span class=\"line\">   <span class=\"keyword\">where</span></span><br><span class=\"line\">     p_left = p mempty vt</span><br><span class=\"line\">     p_right = p vt mempty</span><br><span class=\"line\">     vt = measure t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">searchTree</span> :: (<span class=\"type\">Measured</span> v a) =&gt;</span><br><span class=\"line\">     (v -&gt; v -&gt; <span class=\"type\">Bool</span>) -&gt; v -&gt; <span class=\"type\">FingerTree</span> v a -&gt; v -&gt; <span class=\"type\">Split</span> (<span class=\"type\">FingerTree</span> v a) a</span><br><span class=\"line\"><span class=\"title\">searchTree</span> _ _ <span class=\"type\">Empty</span> _ = illegal_argument <span class=\"string\">\"searchTree\"</span></span><br><span class=\"line\"><span class=\"title\">searchTree</span> _ _ (<span class=\"type\">Single</span> x) _ = <span class=\"type\">Split</span> <span class=\"type\">Empty</span> x <span class=\"type\">Empty</span></span><br><span class=\"line\"><span class=\"title\">searchTree</span> p vl (<span class=\"type\">Deep</span> _ pr m sf) vr</span><br><span class=\"line\">  | p vlp vmsr  =  <span class=\"keyword\">let</span>  <span class=\"type\">Split</span> l x r     =  searchDigit p vl pr vmsr</span><br><span class=\"line\">                   <span class=\"keyword\">in</span>   <span class=\"type\">Split</span> (maybe <span class=\"type\">Empty</span> digitToTree l) x (deepL r m sf)</span><br><span class=\"line\">  | p vlpm vsr  =  <span class=\"keyword\">let</span>  <span class=\"type\">Split</span> ml xs mr  =  searchTree p vlp m vsr</span><br><span class=\"line\">                        <span class=\"type\">Split</span> l x r     =  searchNode p (vlp `mappend` measure ml)       xs (measure mr `mappend` vsr)</span><br><span class=\"line\">                   <span class=\"keyword\">in</span>   <span class=\"type\">Split</span> (deepR pr  ml l) x (deepL r mr sf)</span><br><span class=\"line\">  | otherwise   =  <span class=\"keyword\">let</span>  <span class=\"type\">Split</span> l x r     =  searchDigit p vlpm sf vr</span><br><span class=\"line\">                   <span class=\"keyword\">in</span>   <span class=\"type\">Split</span> (deepR pr  m  l) x (maybe <span class=\"type\">Empty</span> digitToTree r)</span><br><span class=\"line\">  <span class=\"keyword\">where</span></span><br><span class=\"line\">    vlp     =  vl `mappend` measure pr</span><br><span class=\"line\">    vlpm    =  vlp `mappend` vm</span><br><span class=\"line\">    vmsr    =  vm `mappend` vsr</span><br><span class=\"line\">    vsr     =  measure sf `mappend` vr</span><br><span class=\"line\">    vm      =  measure m</span><br></pre></td></tr></table></figure>\n<p>此处只列出了 <code>searchTree</code> 这一子函数，且十分冗长，其实\n<code>searchNode</code> 和 <code>searchDigit</code>\n也类似，本质上就是为了找到第一个使得对于输入的函数，在值左边的分割为假，右边的为真。一步步细化下去而已。</p>\n<p><code>maybe</code> 函数的类型是\n<code>b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b</code>，看类型签名基本可以猜到功能。所以也不细说。</p>\n<p>这里可以看到 <code>where</code> 从句。<code>where</code>\n从句和常量定义很像，但却是后置的，而且具有惰性求值的特征（对，自带Lazy，而且实际上如果不做额外标注，整个\n<code>Haskell</code> 程序都是惰性求值的）。</p>\n<p>到这一步为止，我们只差将原本用于索引的下标整成 <code>Monoid</code>\n就好了，并且其和任意类型均可以构成\n<code>Measured</code>（因为单个元素大小都是1）</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">newtype</span> <span class=\"type\">Size</span> = <span class=\"type\">Size</span> <span class=\"type\">Int</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">newtype</span> <span class=\"type\">Elem</span> a = <span class=\"type\">Elem</span> a</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Monoid</span> <span class=\"type\">Size</span> <span class=\"keyword\">where</span></span></span><br><span class=\"line\">\tmempty = <span class=\"type\">Size</span> <span class=\"number\">0</span></span><br><span class=\"line\">\tmappend (<span class=\"type\">Size</span> a) (<span class=\"type\">Size</span> b) = <span class=\"type\">Size</span> (a+b)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Measured</span> <span class=\"type\">Size</span> (<span class=\"type\">Elem</span> <span class=\"title\">a</span>) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">\tmeasure _ = <span class=\"type\">Size</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>这里注意，由于我们之前使用了\n<code>Functional Dependencies</code>，所以我们需要新建一个类型作为容器来容纳我们的类型。所以此处使用了不会导致额外开销的\n<code>newtype</code> 关键字替代\n<code>data</code>（在当前环境下，二者语义一致）</p>\n<p>接下来就可以实现 <code>Seq</code> 了，具体可以参考\n<code>container</code> 包的源代码或者论文原文。</p>\n","text":" 如果使用 Haskell 语言的话，本题可以使用 containers 包中的 Data.Sequence 秒杀，因为 Seq 本身便是一颗可持久的 FingerTree，用树套树的话，便可以做到一个非常优异的时间/空间复杂度。 惰性求值但是的确是在线算法，可以撤回撤回（返回撤回前的时间点，不知道算不算）。 1234567891011121314151617181920{-# OPTIONS_GHC -O2 #-} -- 强开O2import Control.Monadimport Data.Functor (($>))import Data.Maybe (fromJust)import D...","permalink":"/post/洛谷-P1383-高级打字机","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Online Judge","slug":"Online-Judge","count":2,"path":"api/categories/Online-Judge.json"},{"name":"洛谷","slug":"Online-Judge/洛谷","count":1,"path":"api/categories/Online-Judge/洛谷.json"}],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fingertree%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">FingerTree概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#haskell%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">Haskell基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fingertree-%E5%AE%9E%E7%8E%B0%E7%AE%80%E8%A6%81%E5%A4%8D%E8%BF%B0%E8%AE%BA%E6%96%87\"><span class=\"toc-text\">FingerTree\n实现（简要复述论文）</span></a></li></ol>","author":{"name":"zLeoAlex","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/31839998?s=400&u=b0b96ba70683790361899dd0d4f58987c1857379","link":"/","description":"there are something should not be forgotten, though years apart.","socials":{"github":"https://github.com/LeoAlex0","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"luogu":{"icon":"/imgs/luogu-logo.png","link":"https://www.luogu.com.cn/user/48169"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Incident Algebra与反演","uid":"49a574bbe8143e6df686c9ce01afd268","slug":"反演","date":"2020-06-11T08:10:11.000Z","updated":"2020-06-11T08:10:11.000Z","comments":true,"path":"api/articles/反演.json","keywords":null,"cover":null,"text":"Incidence algebra 定义 局部有限偏序集(locally finite poset)是一种特殊的偏序集，其满足对于所有的闭区间[a, b]是有限的。 偏序关系的性质: 自反性：∀a ∈ S : a ≤ a 反对称性：∀a, b ∈ S : a ≤ b ∧ b ≤ a → a = b 传递性:∀a, b, c ∈ S : a ≤ b ∧ b ≤ c → a ≤ c 偏序集上的区间： [a, b] = {x|a ≤ x ∧ x ≤ b} [a, b) = {x|a ≤ x ∧ x ≤ b ∧ b ≠ x} (a, b] = {x|x ≠ a ∧ a ≤ x ∧ x ≤ b} (a,...","permalink":"/post/反演","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"数学","slug":"数学","count":2,"path":"api/categories/数学.json"},{"name":"代数","slug":"数学/代数","count":1,"path":"api/categories/数学/代数.json"}],"tags":[{"name":"数学","slug":"数学","count":2,"path":"api/tags/数学.json"},{"name":"反演","slug":"反演","count":1,"path":"api/tags/反演.json"}],"author":{"name":"zLeoAlex","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/31839998?s=400&u=b0b96ba70683790361899dd0d4f58987c1857379","link":"/","description":"there are something should not be forgotten, though years apart.","socials":{"github":"https://github.com/LeoAlex0","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"luogu":{"icon":"/imgs/luogu-logo.png","link":"https://www.luogu.com.cn/user/48169"}}}}},"next_post":{"title":"Raspberry PI 3B+刷OpenWRT坑点笔记","uid":"fca4b626abe8dd9b0f5154dab7961f0c","slug":"RPI3B-OpenWrt坑点","date":"2020-05-10T16:24:30.000Z","updated":"2020-05-10T16:24:30.000Z","comments":true,"path":"api/articles/RPI3B-OpenWrt坑点.json","keywords":null,"cover":null,"text":"刷写系统环节 RPI3B和RPI3B+用的同一款固件，可以通用 用个稍微好一点点的读卡器吧，毕竟也有几百M 我Surface上的读卡器插两次就扫不到设备了，十分...","permalink":"/post/RPI3B-OpenWrt坑点","photos":[],"count_time":{"symbolsCount":675,"symbolsTime":"1 mins."},"categories":[{"name":"网络","slug":"网络","count":2,"path":"api/categories/网络.json"}],"tags":[{"name":"Raspberry PI","slug":"Raspberry-PI","count":1,"path":"api/tags/Raspberry-PI.json"},{"name":"OpenWRT","slug":"OpenWRT","count":1,"path":"api/tags/OpenWRT.json"}],"author":{"name":"zLeoAlex","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/31839998?s=400&u=b0b96ba70683790361899dd0d4f58987c1857379","link":"/","description":"there are something should not be forgotten, though years apart.","socials":{"github":"https://github.com/LeoAlex0","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"luogu":{"icon":"/imgs/luogu-logo.png","link":"https://www.luogu.com.cn/user/48169"}}}}}}