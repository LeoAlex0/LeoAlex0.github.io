[{"id":"538d70079edd07a8db8f512d424a9586","title":"Gentoo Minecraft 1.12 RuntimeException: No OpenGL context found in the current thread.","content":"Description\nWhen launching Minecraft 1.12 through MultiMC Launcher, error\nhappens：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[14:37:51] [Client thread/INFO]: Setting user: zLeoAlex[14:37:52] [Client thread/INFO]: LWJGL Version: 2.9.4---- Minecraft Crash Report ----// Quite honestly, I wouldn&#x27;t worry myself about that.Time: 6/7/21 2:37 PMDescription: Initializing gamejava.lang.ExceptionInInitializerError\tat bib.av(SourceFile:661)\tat bib.aq(SourceFile:456)\tat bib.a(SourceFile:404)\tat net.minecraft.client.main.Main.main(SourceFile:123)\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\tat java.lang.reflect.Method.invoke(Method.java:498)\tat org.multimc.onesix.OneSixLauncher.launchWithMainClass(OneSixLauncher.java:196)\tat org.multimc.onesix.OneSixLauncher.launch(OneSixLauncher.java:231)\tat org.multimc.EntryPoint.listen(EntryPoint.java:143)\tat org.multimc.EntryPoint.main(EntryPoint.java:34)Caused by: java.lang.ArrayIndexOutOfBoundsException: 0\tat org.lwjgl.opengl.LinuxDisplay.getAvailableDisplayModes(LinuxDisplay.java:951)\tat org.lwjgl.opengl.LinuxDisplay.init(LinuxDisplay.java:738)\tat org.lwjgl.opengl.Display.&lt;clinit&gt;(Display.java:138)\t... 12 moreA detailed walkthrough of the error, its code path and all known details is as follows:----------------------------------------------------------------------------------------- Head --Thread: Client threadStacktrace:\tat bib.av(SourceFile:661)\tat bib.aq(SourceFile:456)-- Initialization --Details:Stacktrace:\tat bib.a(SourceFile:404)\tat net.minecraft.client.main.Main.main(SourceFile:123)\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\tat java.lang.reflect.Method.invoke(Method.java:498)\tat org.multimc.onesix.OneSixLauncher.launchWithMainClass(OneSixLauncher.java:196)\tat org.multimc.onesix.OneSixLauncher.launch(OneSixLauncher.java:231)\tat org.multimc.EntryPoint.listen(EntryPoint.java:143)\tat org.multimc.EntryPoint.main(EntryPoint.java:34)-- System Details --Details:\tMinecraft Version: 1.12.2\tOperating System: Linux (amd64) version 5.10.27-gentoo-x86_64\tJava Version: 1.8.0_292, Gentoo\tJava VM Version: OpenJDK 64-Bit Server VM (mixed mode), Gentoo\tMemory: 498398744 bytes (475 MB) / 649592832 bytes (619 MB) up to 7635730432 bytes (7282 MB)\tJVM Flags: 2 total; -Xms512m -Xmx8192m\tIntCache: cache: 0, tcache: 0, allocated: 0, tallocated: 0\tLaunched Version: MultiMC5\tLWJGL: 2.9.4\tOpenGL: ~~ERROR~~ RuntimeException: No OpenGL context found in the current thread.\tGL Caps: \tUsing VBOs: Yes\tIs Modded: Probably not. Jar signature remains and client brand is untouched.\tType: Client (map_client.txt)\tResource Packs: \tCurrent Language: ~~ERROR~~ NullPointerException: null\tProfiler Position: N/A (disabled)\tCPU: &lt;unknown&gt;#@!@# Game crashed! Crash report saved to: #@!@# /home/leo/.local/share/multimc/instances/1.12.2/.minecraft/crash-reports/crash-2021-06-07_14.37.52-client.txt\nBut Minecraft 1.16 can be launched successfully.\nFix\nInstall x11-apps/xrandr\n1# emerge -av x11-apps/xrandr\n","slug":"Gentoo-Minecraft-1-12-OpenGL-error","date":"2021-06-07T06:37:02.000Z","categories_index":"Gentoo,Fix","tags_index":"BUG,Minecraft,Gentoo","author_index":"zLeoAlex"},{"id":"69c46b9206ea0522a8e522d7af48dd00","title":"齐次坐标、线性代数与圆锥曲线-1","content":"简介\n本文与其说是一篇文章，不如说是对于这篇文章的简化与总结。\n最终目的是通过引入尽可能少的外部假定，使得我们可以从一个更高的视角看高中的圆锥曲线题。\n基础要素\n观察一个任意二次曲线 Ax2 + Bxy + Cy2 + Dx + Ey + F = 0\n首先，我们可以做如下换元：  其中z为任意实数，则我们可以有： Ax2 + Bxy + Cy2 + Fz2 + Dxz + Eyz = 0\n我们均可以将其写成矩阵相乘的形式:  故我们可以用一个实对称矩阵来表示一个二次曲线。\n另外对于一条直线，如果我们做同样的换元，我们也可以以一个向量来表述它。\n但为了不与点/坐标产生歧义，我们约定后文以行向量表示直线，列向量表示点/坐标。\n\n小结\n\n\n\n\n\n\n\n\n概念\n直角坐标系中\n矩阵表示的齐次坐标中\n\n\n\n\n点\n(xp, yp)\n\n\n\n直线\nAx + By + C = 0\n\n\n\n二次曲线\nAx2 + Bxy + Cy2 + Dx + Ey + F = 0\n\n\n\n点p在直线l上\nl(p) = 0\nlp = 0\n\n\n点p在二次曲线c上\nc(p) = 0\npTcp = 0\n\n\n\n基础原语\n点线关系\n我们都知道两相异的点可以定义出一条直线，两非平行直线也相交于一点。那么在其次坐标中会如何呢？\n\n\n\n\n\n\n\n\n\n也可以选择把无穷远点看作两平行线交点，无穷远线看作相同两点连成的直线。\n这样一样对偶。\n首先看两直线的交点，若存在两直线l1, l2，则其交点p需要同时满足： \n可以看到这与立体几何中“求与两向量同时垂直的第三个向量”这一类问题拥有完全相同的形式。\n而这一问题最简单直接的解法就是作两向量的叉乘。但出于对偶性的要求，此处定义两行矩阵叉乘得到列矩阵，列矩阵叉乘得到行矩阵。\n\n\n\n\n\n\n\n\n\n在向量意义上，简单地，叉乘可以定义为：  其中,i⃗, j⃗, k⃗为各方向上的单位向量。\n注意到：  对于b同理，所以对于c = a × b，任取λ1, λ2，\n我们有：c ⋅ (λ1a + λ2b) = 0\n那么我们可以直接写出上述方程组的解：p = l1 × l2。\n\n\n\n\n\n\n\n\n\n严格意义上是解系cl1 × l2，其中c是常数。\n但常数c大小与解在平面直角坐标系上的对应位置无关，故此处取c = 1\n接下来看过两点的直线，若存在点p1, p2，则其连成的直线l满足：  对等式两边翻转可以得到和上面一样的形式，故其解为：l = p1 × p2\n\n\n\n\n\n\n\n\n概念\n直角坐标中\n矩阵表示的齐次坐标中\n\n\n\n\n直线l1, l2的交点\nl1(p) = l2(p) = 0\n的解\np = l1 × l2\n\n\n过p1, p2的直线\n(x − x1)(y1 − y2) = (y − y1)(x1 − x2)\nl = p1 × p2\n\n\n\n直线与点的线性组合\n注意到，对于两直线的交点p = l1 × l2，对于任意λ1, λ2，\n对两直线的线性组合l = λ1l1 + λ2l2有：\n\n故可知其线性组合亦通过两直线的交点。这对应直角坐标系的一个直线系。\n对偶地，对于两点联结的直线:l = p1 × p2。对p1, p2的任意一个线性组合：\np = λ1p1 + λ2p2。我们有：\n\n其也在二者构成的直线上。\n这与直角坐标系上类似。\n平行\n注意一条特殊的“直线”。\n其与任意直线l的线性组合l′ = λ1l∞ + λ2l与l的交点均无法在直角坐标系内表示。\n\n且其在平面直角坐标系上的表示正好与l平行。故我们可以将所有与l相差任意倍l∞的直线认为其与l平行。\n但对偶地，却代表原点。\n","slug":"齐次坐标、线性代数与圆锥曲线-1","date":"2021-04-30T13:09:12.000Z","categories_index":"数学,几何","tags_index":"数学,齐次坐标","author_index":"zLeoAlex"},{"id":"a2311fa6d52a6ca0be67954ab2f15649","title":"Debian10配置Docker容器访问IPv6问题","content":"打开Docker的IPv6支持\n若想要容器能够监听IPv6的接口，那么首先容器内部需要自己有个IPv6的接口。\n参见docker文档\n修改/etc/docker/daemon.json，合并以下JSON配置\n1234&#123;  &quot;ipv6&quot;: true,  &quot;fixed-cidr-v6&quot;: &quot;2001:db8:1::/64&quot;&#125;\n然后自行systemctl restart docker之类重启docker daemon。\n其中第一项会开启默认的bridge\nnetwork的IPv6支持，下一个会在IPv6的地址池里添加对应的网段。\n不过很奇怪的是，这一个网段的全部地址都会分给全局默认的bridge\nnetwork，所以如果自己的docker-compose文件里有网络需要IPv6支持的，得手动分配一个网段，或者直接改用默认的全局bridge。\n设置ip6tables转发流量\n搞定上面一步之后，理论上你容器内expose出的端口都可以监听IPv6的接口了。但若是想让容器内部访问IPv6的外网，还需要配置ip6tables转发流量。\n参见这个issue\n使用如下命令转发收到的对应地址的流量。\n1ip6tables -t nat -A POSTROUTING -s 2001:db8:1::/64 ! -o docker0 -j MASQUERADE\n但总感觉这个方案还不够完美，只能说暂时够用了。\n","slug":"Docker容器访问IPv6问题","date":"2021-03-18T17:34:32.000Z","categories_index":"网络","tags_index":"Debian,Docker,IPv6","author_index":"zLeoAlex"},{"id":"01937456cef72f998b8b619fdd155a88","title":"[CW]Faberge easter eggs crush test题解(数学部分)","content":"递推式\n按照题意，若设所求函数为F(n, m)，则有：\n\n生成函数\n注意到其生成函数满足 \n移项可得： \n解生成函数\n令: p1 = (1 − x)−1, p2 = (1 − y − xy)−1\n则: G(x, y) = y(1 − y)−1xp1p2\n\n莱布尼兹法则\n注意如下同构 令\n处理p1p2\n解出 \n处理xp1p2\n\n解出G(x, y)\n麦克劳林展开代入前置展开乘进换元乘进来交换求和顺序换元：\n解\n\n","slug":"CW-Faberge-easter-eggs-crush-test","date":"2020-06-27T13:34:50.000Z","categories_index":"Online Judge,CodeWars,1Kyu","tags_index":"组合数学,生成函数","author_index":"zLeoAlex"},{"id":"49a574bbe8143e6df686c9ce01afd268","title":"Incident Algebra与反演","content":"Incidence algebra\n定义\n局部有限偏序集(locally finite\nposet)是一种特殊的偏序集，其满足对于所有的闭区间[a, b]是有限的。\n\n\n\n\n\n\n\n\n\n偏序关系的性质:\n\n自反性：∀a ∈ S : a ≤ a\n反对称性：∀a, b ∈ S : a ≤ b ∧ b ≤ a → a = b\n传递性:∀a, b, c ∈ S : a ≤ b ∧ b ≤ c → a ≤ c\n\n偏序集上的区间：\n\n[a, b] = {x|a ≤ x ∧ x ≤ b}\n[a, b) = {x|a ≤ x ∧ x ≤ b ∧ b ≠ x}\n(a, b] = {x|x ≠ a ∧ a ≤ x ∧ x ≤ b}\n(a, b) = {x|x ≠ a ∧ a ≤ x ∧ x ≤ b ∧ b ≠ x}\n\nIncident algebra中的元素f是一个局部有限偏序集S上的的非空区间[a, b]到一个标量(实际上幺环就足够了)f(a, b)的函数。定义其构成的集合为X，其上的运算定义如下：\n(f * g)(a, b) = ∑x ∈ [a, b]f(a, x)g(x, b)\n有时我们也会在上面额外定义一个加法运算(f + g)(a, b) = f(a, b) + g(a, b)，这将使得其满足一些有趣的性质。\n性质\n结合律\n定义定义分配律交换求和序分配律定义定义\n单位元\n定义函数δ\n\n任意f ∈ X，有：\n\n故 &lt; X, *&gt;构成幺半群(Monoid)，\nδ\n是其单位元，根据幺半群的性质可知它是唯一的单位元。\n分配律\n定义\n(f + g) * h = f * h + g * h类似\n逆\n对于f ∈ X ∧ ∀a ∈ S : f(a, a) ≠ 0，我们可以构造：\n\n因为(a, b] = [a, b] − {a}，且[a, b]是有限的，故上述定义是良构的。\n那么我们有：\n\n另外，，也满足上述条件\n对称地，我们可以构造其另一个方向的逆：\n\n满足(g′ * f) = δ\n故可知∀a ∈ S : f(a, a) ≠ 0是f可逆的充分条件。\n因为1 = δ(a, a) = f(a, a)f−1(a, a)，故其亦是可逆的必要条件（∀x ∈ ℝ : 0 × x = 0，以此反证)\n因此，f可逆的充要条件是∀a ∈ S : f(a, a) ≠ 0\n\n\n\n\n\n\n\n\n\n我们可以构造Incident algebra元素的一个子集 X̂ = {f|f ∈ X ∧ ∀a ∈ S : f(a, a) ≠ 0}，\n那么对于代数结构 &lt; X̂, *&gt;，有：\n\n封闭性(两非0数积非0)\n\n(f * g)(a, a) = f(a, a)g(a, a) ≠ 0\n\n结合律（同 &lt; X, *&gt;)\n有单位元δ ∈ X̂\n有逆(上述已证)\n\n故可知 &lt; X̂, *&gt;构成群\n亦可知 (左右逆元一致，简证如下) g = δ * g = (g′ * f) * g = g′ * f * g = g′ * (f * g) = g′ * δ = g′\n与一般函数之间的关系\n若定义F, G : S → ℝ, f ∈ X̂, a, b ∈ S，且二者满足下列关系:\nF(x) = ∑k ∈ [a, x]G(k)f(k, x)\n则有： 定义分配律交换求和序分配律定义\n\n\n\n\n\n\n\n\n\n本质上，它是F(x) = F′(a, x)的一种等价。\n对称地，也可以构造：  故我们可以在其上构造一个群作用。\n偏序集与ζ函数\n定义\n定义ζ ∈ X为：\n\n因为在X定义时便要求[a, b]构成非空区间，\n而∃x ∈ S : a ≤ x ∧ x ≤ b ⇔ a ≤ b。\n因此其也可以看作ζ(a, b) = 1\n因为∀a ∈ S : ζ(a, a) = 1，所以ζ ∈ X̂\n故可令μ = ζ−1，则有：\n\n令S1, S2为两偏序集，定义S1 × S2上的偏序关系：\n &lt; a1, b1 &gt;  ≤  &lt; a2, b2 &gt;  ⇔ a1 ≤ a2 ∧ b1 ≤ b2\n因此，我们可以定义S1 × S2也是一个偏序集，进一步，有限个偏序集的直积也是一个偏序集。\n性质\n区间[a, b]中元素的个数可以表示为：\nζ2(a, b) = ∑x ∈ [a, b]ζ(a, x)ζ(x, b) = ∑x ∈ [a, b]1 = Card([a, b])\n设局部有限偏序集S1, S2，有S = S1 × S2。若ζ1, ζ2, ζ分别为S1, S2, S上的ζ函数，μ1, μ2, μ分别为S1, S2, S上的μ函数，δ1, δ2, δ分别为S1, S2, S上的δ函数。\n∀a, b ∈ S ∧ a ≤ b，令a =  &lt; a1, a2&gt;,b =  &lt; b1, b2&gt;，易得：\n 进一步地，构造μ′(a, b) = μ1(a1, b1)μ2(a2, b2)，则有:\n定义展开拆开的求和分配律 故μ′ = ζ−1 = μ，即:μ(a, b) = μ1(a1, b1)μ2(a2, b2)\n反演\n二项式反演\n设n次多项式pn(x) = xn, qn(x) = (x − 1)n，则有：\n 可以定义(n + 1) × (n + 1)方阵A, B（下标从0开始）：  可知：\n\nA, B均为单位上三角矩阵\n构造p, q的系数向量可知：AB = BA = I，即A, B互为逆矩阵。\n\n令f(a, b) = Aa, b, g(a, b) = Ba, b。由于A, B均为单位上三角矩阵，\n故f, g可以被看作以[0, n]整数区间，小于等于作为偏序关系的Incident\nalgebra中的元素。 其可以和(n + 1) × (n + 1)矩阵上乘法同构。\n 所以f, g互逆。\n按照Incident algebra与一般函数之间的关系，对[0, n]上一整数a，下两式定义等价：  特别地，对于a = 0，我们有：  一般，我们将此称作二项式反演公式。\n莫比乌斯反演\n将正整数集ℕ+上的整除作为偏序关系。我们可以得到另一个Incident\nalgebra实例。\n其中：  另外，通过数学归纳，注意到：  而且，当a ∣ b时，μ(a, b)有意义（或者说可能不为0）。 故我们可以构造函数，即可简化计算。 那么，我们有：  这个函数又被称作经典莫比乌斯函数。\n按照Incident algebra与一般函数之间的关系，取下限a = 1(故任取k均与a整除)，我们有下述两等价定义：  其中称下式为上式的莫比乌斯反演公式。\n","slug":"反演","date":"2020-06-11T08:10:11.000Z","categories_index":"数学,代数","tags_index":"数学,反演","author_index":"zLeoAlex"},{"id":"0eee92f956429317e7277e463252038c","title":"洛谷-P1383 高级打字机 题解","content":"\n如果使用 Haskell 语言的话，本题可以使用 containers\n包中的 Data.Sequence 秒杀，因为 Seq\n本身便是一颗可持久的\nFingerTree，用树套树的话，便可以做到一个非常优异的时间/空间复杂度。\n惰性求值但是的确是在线算法，可以撤回撤回（返回撤回前的时间点，不知道算不算）。\n1234567891011121314151617181920{-# OPTIONS_GHC -O2 #-} -- 强开O2import           Control.Monadimport           Data.Functor  (($&gt;))import           Data.Maybe    (fromJust)import           Data.Sequenceimport           Text.Printf   (printf)(!) = index -- 强行把函数变成运算符main :: IO ()main = do    n &lt;- readLn :: IO Int -- 读取第一行的整数n，需要手动指定类型，不然会有歧义    fromList [fromList []] `foldM_'` [1..n] $ \\seq _ -&gt; do -- 函数的中缀用法，注意初始的历史记录应该有一个空串        [[op],c] &lt;- words &lt;$&gt; getLine -- 读取每一行的指令，此处使用了模式匹配（见下文）        case op of            'T' -&gt; pure $ (seq!0 |&gt; head c) &lt;| seq  -- 历史记录第0号（即上一次修改的结果）后插入当前字符，然后前插入历史记录            'U' -&gt; pure $ (seq!read c) &lt;| seq -- 将参数读取为整数（此处无需标明，因为函数有明确的类型限制，编译器将自动推导） 取历史记录的相应项，前插入历史记录            'Q' -&gt; printf \"%c\\n\" (seq!0!(read c-1))  $&gt; seq -- 将上一次修改的结果的相应位置的字符打印出来，并返回本身的历史记录（($ &gt;)运算符特性）foldM_' z l f = foldM_ f z l -- 调整参数位置，追求好用\n代码十分朴素。\n\n空间复杂度: O(nlog n) ，其中\nn\n为总字符数（不是很紧确，但是..能过）\n每次从后面添加字符，时间复杂度: O(1)\n每次打印第 i\n个字符，时间复杂度: O(log (min (i, n − i)))\n，其中 n 为当前字符数， i 为需要打印的字符位置。\n每次撤销，时间复杂度: O(log (min (i, n − i)))\n，其中 n 为总修改次数，i 为撤销步数。\n总时间复杂度可估算为: O(nlog n)\n\n如果想看 FingerTree 原理或者希望以此为契机了解一下\nHaskell 的话参见后文。也可以参考论文原文。\n参考文献：\n\nHinze R, Paterson R. Finger trees: a simple general-purpose data\nstructure[J]. Journal of functional programming, 2006, 16(2):\n197-217.\nhttps://hackage.haskell.org/package/fingertree\nhttps://hackage.haskell.org/package/container\nhttps://wiki.haskell.org/Functional_dependencies\n\nFingerTree概述\n说到可持久化，就得想到 Immutable ，说到 Immutable\n，自然而然就是函数式编程语言，说到函数式编程语言，自然而然就是\nHaskell ，而说到纯函数式的数据结构，自然而然也绕不开\nFingerTree 。\nFingerTree\n是一种理论上非常通用也非常高效的数据结构，插入头/尾都只需要摊还 O(1) 的时间，\n而对其的“随机”访问只需要 O(log min (i, n − i))\n&gt; 其中 i\n为你访问的下标，所以可以看出访问头/尾其实也是 O(1) 。\n关于它的论文可以戳这里。当然这不是最早的一篇，但我看的就是这篇，才疏学浅没办法在这里列更早的。\n但为什么说“理论”上呢，就和斐波那契堆类似，他的常数比较大。（主要因素是Immutable的语言必须维护一个GC来做垃圾回收。）\n\n\n\n\n\n\n\n\n\n[更新] 事后我拿 Rust 实现了一遍 FingerTree\n，发现其时空消耗均比 Haskell 大，故可认为并非GC原因。\n不过也有可能是我写的常数就是大呢（\n详见：提交记录\n那为什么说“随机”呢？因为完全泛化的 FingerTree\n的访问依赖的不是下标，而是一个被称作 Measure\n（测度？我也不知道怎么翻译，所以直接拉的原文）的幺半群\n(Monoid)。\n\n\n\n\n\n\n\n\n\n先解释一下什么是幺半群。幺半群是一个集合 X 和集合里元素之间一个二元运算 ⋅ : X × X → X\n的统称（有序对），并要求：\n\n二元运算满足结合率，即 ∀x, y, z ∈ X : (x ⋅ y) ⋅ z = x ⋅ (y ⋅ z)\n集合 X\n中存在一个单位元，即 ∃e : (∀x : e ⋅ x = x ⋅ e = x)\n\n比如说自然数集 ℕ 与其上的加法 +\n便可以构成一个幺半群（后面我们可以用这条性质做出传统意义上的下标索引）\n进一步，我们可以定义两个幺半群的笛卡尔积也是一个幺半群，即对于 (X, ⋅1) 与 (Y, ⋅2) ，\n我们可以定义一个运算 ⋅ : (X × Y) × (X × Y) → X × Y\n，并使其满足结合率。定义方法如下：\n\n(x1, y1) ⋅ (x2, y2) = (x1⋅1x2, y1⋅2y2)\n\n我们可以用这个条件来拓展我们索引方式（比如论文原文里可以看到用 max  幺半群实现的最大堆/优先队列）\nHaskell基础\n首先，用 Haskell\n的方式定义一下幺半群（实际上这个标准库有，不需要自己实现）\n123class Monoid a where    mempty :: a    mappend :: a -&gt; a -&gt; a\n与常用的C-like语言中的 class 不同，在\nHaskell 中，这代表一个类型类，是对类型 a\n的一种约束，类似于接口/抽象类一类的概念。\n然后是 Foldable ，它代表我们可以在一个类型(其实是一个\nKind\n，拿类型生成类型的类型构造子)上按照某种顺序去遍历。类似于\nJava 8 中的 reduce\n。注意这个其实标准库也有，只是提一嘴。\n123class Foldable f where    foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b    foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b\n还需要提一嘴的是 Haskell\n最基本的数据结构，链表(实际上还是单端链表，所以只提供最基本的功能)。\n1data [] a = [] | a:([] a)\n它意味着一个 a\n类型的链表有两种构造方式，一种是空链表，令一种是一个 a 类型的元素用 :\n运算符拼接一个 a\n类型的链表。（对，中缀构造函数， C++ 是做不到这点的。）\n另外还有一个比较常用的 data 被称作 Maybe\n，它的定义等价于：\n1data Maybe a = Nothing | Just a\n想一想，这个定义是什么意思？\n从这里开始就可以看到 Haskell\n的一些特性了。Haskell\n中的数据结构并非由字段和操作构成，而是由几类数据的组合组合而成。当然它是可以实现上面的俩\nclass 的。这里我不做过多介绍。\nFingerTree\n实现（简要复述论文）\n\n\nFingerTree 概要图\n\n首先是一些基础定义。\n1234567891011121314-- | Things that can be measured.class (Monoid v) =&gt; Measured v a | a -&gt; v where    measure :: a -&gt; vdata Node v a = Node2 v a a | Node3 v a a adata Digit a    = One a    | Two a a    | Three a a a    | Four a a a adata FingerTree v a     = Empty     | Single a     | Deep v (Digit a) (FingerTree v (Node v a)) (Digit a)\n这里开始出现了最开始提到的\nMeasured，此处将其抽象为一个可以将某个元素测量出一个\nMonoid 的函数。但这个 Monoid 有大用。\n此处出现的语法使用了一个 Functional Dependencies\n的拓展(可参见 wiki\n)。大概意思是保证对于一个类型，我只能把它 measure\n成一种其他类型，不能 measure 成另一种。也就是说，类型\na 到类型 v 是一个单射。\n可以看到这里的 v\n类型变元，这个就是稍后要维护的\nMonoid，也是索引数据的依据。\n可以看到一个 Node 可能有2-3个元素，保证一个\nDigit 有 1-4\n个元素。(图中也可以看出，不过引用链接是国外的可能比较卡)\nDigit 和 Node\n也可以相互转化，拼接，但后文不再说明实现。\n还有一点值得注意的是，如果当前这一层的 FingerTree\n缓存的是 a 类型的话，那么下一层所缓存的就是\nNode a 类型了。这也就意味着，下层比上层“厚实”。\n自然地，我们可以给 Node 和 Digit 来个\nFoldable，但具体部分就不展示了。\n那么我们应该如何方便的维护这个 v\n类型的数据呢，答案是换一种方式重写构造函数。\n123deep ::  (Measured v a) =&gt;      Digit a -&gt; FingerTree v (Node v a) -&gt; Digit a -&gt; FingerTree v a deep pr m sf = Deep ((measure pr `mappend` measure m) `mappend` measure sf) pr m sf\n此处的 mappend 是 Haskell\n里函数的中缀用法（就是把函数当运算符用）。\n此时，我们不需要每次构造树的时候手动维护 v 类型的数据了，只需要简单把\nDeep 替换为 deep 即可。\n另外，关于 Measured 本身，我们也可以让\nFingerTree 也是 Measured，具体代码如下：\n1234instance (Measured v a) =&gt; Measured v (FingerTree v a) where      measure Empty           =  mempty      measure (Single x)      =  measure x      measure (Deep v _ _ _)  =  v\n注意到此处使用了 Haskell 被称作模式匹配\n(Pattern\nMatch)的特性。（不是模式串匹配啦）把数据结构重新打回了它最开始定义时的样子，并且怎么被构造的就怎么被匹配。(真-打回娘胎)\n\n\n\n\n\n\n\n\n\n模式匹配不止可以匹配一层，也可以匹配多层。至于用途嘛..请自行搜索\nHaskell 的 20 行红黑树。\n可以看到对于 Deep 一类，我们直接使用了其缓存的 v 类型字段，这样就可以在 O(1)\n时间内得到一颗子树的测度。(如果对单个元素的 measure 也是\nO(1) 的话)\n当然 Node 和 Digit 也可以是\nMeasured，具体实现请自行脑补。\n接下来是前插入的定义。\n123456789infixr 5 &lt;|-- | /O(1)/. Add an element to the left end of a sequence.-- Mnemonic: a triangle with the single element at the pointy end.(&lt;|) :: Measured v a =&gt; a -&gt; FingerTree v a -&gt; FingerTree v aa &lt;| Empty              =  Single aa &lt;| Single b           =  deep (One a) Empty (One b)a &lt;| Deep v (Four b c d e) m sf    = Deep (measure a `mappend` v) (Two a b) (node3 c d e &lt;| m) sfa &lt;| Deep v pr m sf     = Deep (measure a `mappend` v) (consDigit a pr) m sf\n注意到这里我们自定义了一个运算符，它的优先级是5,并且是右结合的。（不愧是\nHaskell，轻易做到了 C++ 做不到的事情。）\nconsDigit 就是给 pr\n前插入一个元素。当然，如果是满的肯定会报错，但是在它之前的模式匹配会避免这一点发生。\n类似地还有后插入\n123456789infixl 5 .-- | /O(1)/. Add an element to the right end of a sequence.-- Mnemonic: a triangle with the single element at the pointy end.(|&gt;) :: (Measured v a) =&gt; FingerTree v a -&gt; a -&gt; FingerTree v aEmpty |&gt; a              =  Single aSingle a |&gt; b           =  deep (One a) Empty (One b)Deep v pr m (Four a b c d) |&gt; e    = Deep (v `mappend` measure e) pr (m |&gt; node3 a b c) (Two d e)Deep v pr m sf |&gt; x     = Deep (v `mappend` measure x) pr m (snocDigit sf x)\n可以看到代码基本上和前插入是对称的。（数据结构本身也是对称的，所以这里写作\nsnocDigit，其中 snoc 正是 cons\n的回文）后面还有很多对称的结构，均以左半部分为例。\n然后是一个分割原语（当然右侧也是对称的，可以看到又出现了运算符构造子。）\n12345678910111213141516-- | View of the left end of a sequence.data ViewL s a     = EmptyL        -- ^ empty sequence     | a :&lt; s a      -- ^ leftmost element and the rest of the sequence-- | /O(1)/. Analyse the left end of a sequence.viewl :: (Measured v a) =&gt; FingerTree v a -&gt; ViewL (FingerTree v) aviewl Empty                     =  EmptyLviewl (Single x)                =  x :&lt; Emptyviewl (Deep _ (One x) m sf)     =  x :&lt; rotL m sfviewl (Deep _ pr m sf)          =  lheadDigit pr :&lt; deep (ltailDigit pr) m sfrotL :: (Measured v a) =&gt; FingerTree v (Node v a) -&gt; Digit a -&gt; FingerTree v arotL m sf      =   case viewl m of    EmptyL  -&gt;  digitToTree sf    a :&lt; m' -&gt;  Deep (measure m `mappend` measure sf) (nodeToDigit a) m' sf\nlheadDigit 和 ltailDigit 是指一个\nDigit 的最左边元素和剩下的元素，当然如果 Digit\n只有一个元素的画 ltail\n就会报错，但是前面的模式匹配也避免了这一点。\ndigitToTree 是一个将 Digit 变为一个\nFingerTree 的函数，因为也就常数个元素，所以时间复杂度 O(1)。\nnodeToDigit 也是跟名字异样，将一个\nNode(2或3个元素)变成一个 Digit。\ncase ... of 语法是 Haskell 类似于\nC++ 的 switch\n语句的地方。不同之处在于其是有返回值的，更像一个多出口的 ?:\n运算符。\nviewl\n函数构造一颗树的左分割，将其切割出最左元素（若没有则用\nEmptyL 构造子）。\n另外值得注意的是此处的 viewl 和 rotL\n是互相调用，也是一种递归哦。\n当然其有对称实现 viewr。但不在此赘述。\n有了 viewl 之后，我们就可以处理一些 prefix\n(即 Deep 中第一个\nDigit)为空/不存在时对树的构造了\n1234deepL :: (Measured v a) =&gt;    Maybe (Digit a) -&gt; FingerTree v (Node v a) -&gt; Digit a -&gt; FingerTree v adeepL Nothing m sf      =   rotL m sfdeepL (Just pr) m sf    =   deep pr m sf\n此处的 Nothing 就是指 prefix\n不存在的情况，此时需要左旋一波。\n当然对于 Just 的情况就直接调用上面的deep了。\n那么什么情况下左边/右边为空呢？当然是做分割的时候了。\n那么终于，要迎来最后的部分了，搜索，与分割。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647data Split t a = Split t a tdata SearchResult v a    = Position (FingerTree v a) a (FingerTree v a)        -- ^ A tree opened at a particular element: the prefix to the       -- left, the element, and the suffix to the right.   | OnLeft       -- ^ A position to the left of the sequence, indicating that the       -- predicate is 'True' at both ends.   | OnRight       -- ^ A position to the right of the sequence, indicating that the       -- predicate is 'False' at both ends.   | Nowhere       -- ^ No position in the tree, returned if the predicate is 'True'       -- at the left end and 'False' at the right end.  This will not       -- occur if the predicate in monotonic on the tree.search :: (Measured v a) =&gt;    (v -&gt; v -&gt; Bool) -&gt; FingerTree v a -&gt; SearchResult v asearch p t  | p_left &amp;&amp; p_right = OnLeft  | not p_left &amp;&amp; p_right = case searchTree p mempty t mempty of         Split l x r -&gt; Position l x r  | not p_left &amp;&amp; not p_right = OnRight  | otherwise = Nowhere   where     p_left = p mempty vt     p_right = p vt mempty     vt = measure tsearchTree :: (Measured v a) =&gt;     (v -&gt; v -&gt; Bool) -&gt; v -&gt; FingerTree v a -&gt; v -&gt; Split (FingerTree v a) asearchTree _ _ Empty _ = illegal_argument \"searchTree\"searchTree _ _ (Single x) _ = Split Empty x EmptysearchTree p vl (Deep _ pr m sf) vr  | p vlp vmsr  =  let  Split l x r     =  searchDigit p vl pr vmsr                   in   Split (maybe Empty digitToTree l) x (deepL r m sf)  | p vlpm vsr  =  let  Split ml xs mr  =  searchTree p vlp m vsr                        Split l x r     =  searchNode p (vlp `mappend` measure ml)       xs (measure mr `mappend` vsr)                   in   Split (deepR pr  ml l) x (deepL r mr sf)  | otherwise   =  let  Split l x r     =  searchDigit p vlpm sf vr                   in   Split (deepR pr  m  l) x (maybe Empty digitToTree r)  where    vlp     =  vl `mappend` measure pr    vlpm    =  vlp `mappend` vm    vmsr    =  vm `mappend` vsr    vsr     =  measure sf `mappend` vr    vm      =  measure m\n此处只列出了 searchTree 这一子函数，且十分冗长，其实\nsearchNode 和 searchDigit\n也类似，本质上就是为了找到第一个使得对于输入的函数，在值左边的分割为假，右边的为真。一步步细化下去而已。\nmaybe 函数的类型是\nb -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b，看类型签名基本可以猜到功能。所以也不细说。\n这里可以看到 where 从句。where\n从句和常量定义很像，但却是后置的，而且具有惰性求值的特征（对，自带Lazy，而且实际上如果不做额外标注，整个\nHaskell 程序都是惰性求值的）。\n到这一步为止，我们只差将原本用于索引的下标整成 Monoid\n就好了，并且其和任意类型均可以构成\nMeasured（因为单个元素大小都是1）\n1234567newtype Size = Size Intnewtype Elem a = Elem ainstance Monoid Size where\tmempty = Size 0\tmappend (Size a) (Size b) = Size (a+b)instance Measured Size (Elem a) where\tmeasure _ = Size 1\n这里注意，由于我们之前使用了\nFunctional Dependencies，所以我们需要新建一个类型作为容器来容纳我们的类型。所以此处使用了不会导致额外开销的\nnewtype 关键字替代\ndata（在当前环境下，二者语义一致）\n接下来就可以实现 Seq 了，具体可以参考\ncontainer 包的源代码或者论文原文。\n","slug":"洛谷-P1383-高级打字机","date":"2020-05-19T16:23:53.000Z","categories_index":"Online Judge,洛谷","tags_index":"算法,数据结构","author_index":"zLeoAlex"},{"id":"fca4b626abe8dd9b0f5154dab7961f0c","title":"Raspberry PI 3B+刷OpenWRT坑点笔记","content":"刷写系统环节\n\nRPI3B和RPI3B+用的同一款固件，可以通用\n用个稍微好一点点的读卡器吧，毕竟也有几百M\n\n\n\n\n\n\n\n\n\n我Surface上的读卡器插两次就扫不到设备了，十分蛇皮\nUSB 读卡器又有点点接触不良，刷个几百k就一个读写错误，心累.jpg\n如果希望能完全使用TF卡的空间，单纯的resize分区是不行的，还要记得fsck然后跑一遍resize2fs\n&gt; 不知道为什么我先配完系统之后改大小然后就崩了。 &gt; &gt;\n但是如果在第一次启动前把分区大小调好就没事。\nWiFi的启用需要等到第一次启动以后，第一次启动的时候会生成配置文件，之后改改就好\n如果需要用USB to TTL之类的操作连接PI，那么还要改config.txt，没改成功过，不细说\n\n配置环节\n\n信道填自动就搜不到WiFi了不知道咋回事儿\n\n802.11ac的52-64信道在国内要求DFS/TPC(动态频率选择和传输功率控制)，可能是因为树莓派并没有相应的功能还往这几个信道上挤导致的。\n\nwan的接口名一定要小写，一定要小写，一定要小写，或者手动修改为防火墙wan区域\n刚配好时opkg镜像不能用https，只能走http，因为里面套件还不全\n\n网络配置\n多拨\n\n使用mwan3插件\n前面接个AP模式的路由器\n使用ip link add link eth0 name vethX type macvlan来添加虚拟网口\n其中留一个虚拟网口接br-lan接口，其余每个一个PPPoE接口\n设置mwan3的时候一定要填测试IP，让相应的策略能自动开启\n\n","slug":"RPI3B-OpenWrt坑点","date":"2020-05-10T16:24:30.000Z","categories_index":"网络","tags_index":"Raspberry PI,OpenWRT","author_index":"zLeoAlex"}]