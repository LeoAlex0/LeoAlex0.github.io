[{"id":"538d70079edd07a8db8f512d424a9586","title":"Gentoo Minecraft 1.12 RuntimeException: No OpenGL context found in the current thread.","content":"Description\nWhen launching Minecraft 1.12 through MultiMC Launcher, error\nhappens：\n[14:37:51] [Client thread&#x2F;INFO]: Setting user: zLeoAlex\n[14:37:52] [Client thread&#x2F;INFO]: LWJGL Version: 2.9.4\n---- Minecraft Crash Report ----\n&#x2F;&#x2F; Quite honestly, I wouldn&#39;t worry myself about that.\n\nTime: 6&#x2F;7&#x2F;21 2:37 PM\nDescription: Initializing game\n\njava.lang.ExceptionInInitializerError\n\tat bib.av(SourceFile:661)\n\tat bib.aq(SourceFile:456)\n\tat bib.a(SourceFile:404)\n\tat net.minecraft.client.main.Main.main(SourceFile:123)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.multimc.onesix.OneSixLauncher.launchWithMainClass(OneSixLauncher.java:196)\n\tat org.multimc.onesix.OneSixLauncher.launch(OneSixLauncher.java:231)\n\tat org.multimc.EntryPoint.listen(EntryPoint.java:143)\n\tat org.multimc.EntryPoint.main(EntryPoint.java:34)\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 0\n\tat org.lwjgl.opengl.LinuxDisplay.getAvailableDisplayModes(LinuxDisplay.java:951)\n\tat org.lwjgl.opengl.LinuxDisplay.init(LinuxDisplay.java:738)\n\tat org.lwjgl.opengl.Display.&lt;clinit&gt;(Display.java:138)\n\t... 12 more\n\n\nA detailed walkthrough of the error, its code path and all known details is as follows:\n---------------------------------------------------------------------------------------\n\n-- Head --\nThread: Client thread\nStacktrace:\n\tat bib.av(SourceFile:661)\n\tat bib.aq(SourceFile:456)\n\n-- Initialization --\nDetails:\nStacktrace:\n\tat bib.a(SourceFile:404)\n\tat net.minecraft.client.main.Main.main(SourceFile:123)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.multimc.onesix.OneSixLauncher.launchWithMainClass(OneSixLauncher.java:196)\n\tat org.multimc.onesix.OneSixLauncher.launch(OneSixLauncher.java:231)\n\tat org.multimc.EntryPoint.listen(EntryPoint.java:143)\n\tat org.multimc.EntryPoint.main(EntryPoint.java:34)\n\n-- System Details --\nDetails:\n\tMinecraft Version: 1.12.2\n\tOperating System: Linux (amd64) version 5.10.27-gentoo-x86_64\n\tJava Version: 1.8.0_292, Gentoo\n\tJava VM Version: OpenJDK 64-Bit Server VM (mixed mode), Gentoo\n\tMemory: 498398744 bytes (475 MB) &#x2F; 649592832 bytes (619 MB) up to 7635730432 bytes (7282 MB)\n\tJVM Flags: 2 total; -Xms512m -Xmx8192m\n\tIntCache: cache: 0, tcache: 0, allocated: 0, tallocated: 0\n\tLaunched Version: MultiMC5\n\tLWJGL: 2.9.4\n\tOpenGL: ~~ERROR~~ RuntimeException: No OpenGL context found in the current thread.\n\tGL Caps: \n\tUsing VBOs: Yes\n\tIs Modded: Probably not. Jar signature remains and client brand is untouched.\n\tType: Client (map_client.txt)\n\tResource Packs: \n\tCurrent Language: ~~ERROR~~ NullPointerException: null\n\tProfiler Position: N&#x2F;A (disabled)\n\tCPU: &lt;unknown&gt;\n#@!@# Game crashed! Crash report saved to: #@!@# &#x2F;home&#x2F;leo&#x2F;.local&#x2F;share&#x2F;multimc&#x2F;instances&#x2F;1.12.2&#x2F;.minecraft&#x2F;crash-reports&#x2F;crash-2021-06-07_14.37.52-client.txt\nBut Minecraft 1.16 can be launched successfully.\nFix\nInstall x11-apps/xrandr\n# emerge -av x11-apps&#x2F;xrandr\n","slug":"Gentoo-Minecraft-1-12-OpenGL-error","date":"2021-06-07T06:37:02.000Z","categories_index":"Gentoo,Fix","tags_index":"BUG,Minecraft,Gentoo","author_index":"zLeoAlex"},{"id":"69c46b9206ea0522a8e522d7af48dd00","title":"齐次坐标、线性代数与圆锥曲线-1","content":"简介\n本文与其说是一篇文章，不如说是对于这篇文章的简化与总结。\n最终目的是通过引入尽可能少的外部假定，使得我们可以从一个更高的视角看高中的圆锥曲线题。\n基础要素\n观察一个任意二次曲线  首先，我们可以做如下换元：  其中为任意实数，则我们可以有：  我们均可以将其写成矩阵相乘的形式:  故我们可以用一个实对称矩阵来表示一个二次曲线。\n另外对于一条直线，如果我们做同样的换元，我们也可以以一个向量来表述它。\n但为了不与点/坐标产生歧义，我们约定后文以行向量表示直线，列向量表示点/坐标。\n\n小结\n\n\n\n\n\n\n\n\n概念\n直角坐标系中\n矩阵表示的齐次坐标中\n\n\n\n\n点\n\n\n\n\n直线\n\n\n\n\n二次曲线\n\n\n\n\n点在直线上\n\n\n\n\n点在二次曲线上\n\n\n\n\n\n基础原语\n点线关系\n我们都知道两相异的点可以定义出一条直线，两非平行直线也相交于一点。那么在其次坐标中会如何呢？\n\n\n\n\n\n\n\n\n\n也可以选择把无穷远点看作两平行线交点，无穷远线看作相同两点连成的直线。\n这样一样对偶。\n首先看两直线的交点，若存在两直线，则其交点需要同时满足： \n可以看到这与立体几何中“求与两向量同时垂直的第三个向量”这一类问题拥有完全相同的形式。\n而这一问题最简单直接的解法就是作两向量的叉乘。但出于对偶性的要求，此处定义两行矩阵叉乘得到列矩阵，列矩阵叉乘得到行矩阵。\n\n\n\n\n\n\n\n\n\n在向量意义上，简单地，叉乘可以定义为：  其中,为各方向上的单位向量。 注意到：  对于同理，所以对于，任取， 我们有：\n那么我们可以直接写出上述方程组的解：。\n\n\n\n\n\n\n\n\n\n严格意义上是解系，其中是常数。\n但常数大小与解在平面直角坐标系上的对应位置无关，故此处取\n接下来看过两点的直线，若存在点，则其连成的直线满足：  对等式两边翻转可以得到和上面一样的形式，故其解为：\n\n\n\n\n\n\n\n\n概念\n直角坐标中\n矩阵表示的齐次坐标中\n\n\n\n\n直线的交点\n 的解\n\n\n\n过的直线\n\n\n\n\n\n直线与点的线性组合\n注意到，对于两直线的交点，对于任意，\n对两直线的线性组合有： \n故可知其线性组合亦通过两直线的交点。这对应直角坐标系的一个直线系。\n对偶地，对于两点联结的直线:。对的任意一个线性组合： 。我们有：\n\n其也在二者构成的直线上。\n这与直角坐标系上类似。\n平行\n注意一条特殊的“直线”。\n其与任意直线的线性组合与的交点均无法在直角坐标系内表示。\n\n且其在平面直角坐标系上的表示正好与平行。故我们可以将所有与相差任意倍的直线认为其与平行。\n但对偶地，却代表原点。\n","slug":"齐次坐标、线性代数与圆锥曲线-1","date":"2021-04-30T13:09:12.000Z","categories_index":"数学,几何","tags_index":"数学,齐次坐标","author_index":"zLeoAlex"},{"id":"a2311fa6d52a6ca0be67954ab2f15649","title":"Debian10配置Docker容器访问IPv6问题","content":"打开Docker的IPv6支持\n若想要容器能够监听IPv6的接口，那么首先容器内部需要自己有个IPv6的接口。\n参见docker文档\n修改/etc/docker/daemon.json，合并以下JSON配置\n&#123;\n  &quot;ipv6&quot;: true,\n  &quot;fixed-cidr-v6&quot;: &quot;2001:db8:1::&#x2F;64&quot;\n&#125;\n然后自行systemctl restart docker之类重启docker daemon。\n其中第一项会开启默认的bridge\nnetwork的IPv6支持，下一个会在IPv6的地址池里添加对应的网段。\n不过很奇怪的是，这一个网段的全部地址都会分给全局默认的bridge\nnetwork，所以如果自己的docker-compose文件里有网络需要IPv6支持的，得手动分配一个网段，或者直接改用默认的全局bridge。\n设置ip6tables转发流量\n搞定上面一步之后，理论上你容器内expose出的端口都可以监听IPv6的接口了。但若是想让容器内部访问IPv6的外网，还需要配置ip6tables转发流量。\n参见这个issue\n使用如下命令转发收到的对应地址的流量。\nip6tables -t nat -A POSTROUTING -s 2001:db8:1::&#x2F;64 ! -o docker0 -j MASQUERADE\n但总感觉这个方案还不够完美，只能说暂时够用了。\n","slug":"Docker容器访问IPv6问题","date":"2021-03-18T17:34:32.000Z","categories_index":"网络","tags_index":"Debian,Docker,IPv6","author_index":"zLeoAlex"},{"id":"01937456cef72f998b8b619fdd155a88","title":"[CW]Faberge easter eggs crush test题解(数学部分)","content":"递推式\n按照题意，若设所求函数为，则有： \n生成函数\n注意到其生成函数满足 \n移项可得： \n解生成函数\n令: \n则: \n\n莱布尼兹法则\n注意如下同构 令\n处理\n解出 \n处理\n\n解出\n麦克劳林展开代入前置展开乘进换元乘进来交换求和顺序换元：\n解\n\n","slug":"CW-Faberge-easter-eggs-crush-test","date":"2020-06-27T13:34:50.000Z","categories_index":"Online Judge,CodeWars,1Kyu","tags_index":"组合数学,生成函数","author_index":"zLeoAlex"},{"id":"49a574bbe8143e6df686c9ce01afd268","title":"Incident Algebra与反演","content":"Incidence algebra\n定义\n局部有限偏序集(locally finite\nposet)是一种特殊的偏序集，其满足对于所有的闭区间是有限的。\n\n\n\n\n\n\n\n\n\n偏序关系的性质:\n\n自反性：\n反对称性：\n传递性:\n\n偏序集上的区间：\n\n\n\n\n\n\nIncident algebra中的元素是一个局部有限偏序集上的的非空区间到一个标量(实际上幺环就足够了)的函数。定义其构成的集合为，其上的运算定义如下：\n\n有时我们也会在上面额外定义一个加法运算，这将使得其满足一些有趣的性质。\n性质\n结合律\n定义定义分配律交换求和序分配律定义定义\n单位元\n定义函数\n\n任意，有：\n\n故构成幺半群(Monoid)， \n是其单位元，根据幺半群的性质可知它是唯一的单位元。\n分配律\n定义\n类似\n逆\n对于，我们可以构造：\n\n因为，且是有限的，故上述定义是良构的。\n那么我们有：\n\n另外，，也满足上述条件\n对称地，我们可以构造其另一个方向的逆：\n\n满足\n故可知是可逆的充分条件。\n因为，故其亦是可逆的必要条件（，以此反证)\n因此，可逆的充要条件是\n\n\n\n\n\n\n\n\n\n我们可以构造Incident algebra元素的一个子集 ， 那么对于代数结构，有：\n\n封闭性(两非数积非)\n\n\n\n结合律（同)\n有单位元\n有逆(上述已证)\n\n故可知构成群\n亦可知 (左右逆元一致，简证如下) \n与一般函数之间的关系\n若定义，且二者满足下列关系:  则有： 定义分配律交换求和序分配律定义\n\n\n\n\n\n\n\n\n\n本质上，它是的一种等价。\n对称地，也可以构造：  故我们可以在其上构造一个群作用。\n偏序集与函数\n定义\n定义为：\n\n因为在定义时便要求构成非空区间， 而。 因此其也可以看作\n因为，所以\n故可令，则有：\n\n令为两偏序集，定义上的偏序关系：\n\n因此，我们可以定义也是一个偏序集，进一步，有限个偏序集的直积也是一个偏序集。\n性质\n区间中元素的个数可以表示为：\n\n设局部有限偏序集，有。若分别为上的函数，分别为上的函数，分别为上的函数。\n，令，易得：\n 进一步地，构造，则有:\n定义展开拆开的求和分配律 故，即:\n反演\n二项式反演\n设次多项式，则有：  可以定义方阵（下标从0开始）：  可知：\n\n均为单位上三角矩阵\n构造的系数向量可知：，即互为逆矩阵。\n\n令。由于均为单位上三角矩阵， 故可以被看作以整数区间，小于等于作为偏序关系的Incident\nalgebra中的元素。 其可以和矩阵上乘法同构。  所以互逆。\n按照Incident algebra与一般函数之间的关系，对上一整数，下两式定义等价：  特别地，对于，我们有：\n 一般，我们将此称作二项式反演公式。\n莫比乌斯反演\n将正整数集上的整除作为偏序关系。我们可以得到另一个Incident\nalgebra实例。\n其中：  另外，通过数学归纳，注意到：  而且，当时，有意义（或者说可能不为）。 故我们可以构造函数，即可简化计算。 那么，我们有：  这个函数又被称作经典莫比乌斯函数。\n按照Incident algebra与一般函数之间的关系，取下限(故任取均与整除)，我们有下述两等价定义：  其中称下式为上式的莫比乌斯反演公式。\n","slug":"反演","date":"2020-06-11T08:10:11.000Z","categories_index":"数学,代数","tags_index":"数学,反演","author_index":"zLeoAlex"},{"id":"0eee92f956429317e7277e463252038c","title":"洛谷-P1383 高级打字机 题解","content":"\n如果使用 Haskell 语言的话，本题可以使用 containers\n包中的 Data.Sequence 秒杀，因为 Seq\n本身便是一颗可持久的\nFingerTree，用树套树的话，便可以做到一个非常优异的时间/空间复杂度。\n惰性求值但是的确是在线算法，可以撤回撤回（返回撤回前的时间点，不知道算不算）。\n{-# OPTIONS_GHC -O2 #-} -- 强开O2\nimport           Control.Monad\nimport           Data.Functor  (($&gt;))\nimport           Data.Maybe    (fromJust)\nimport           Data.Sequence\nimport           Text.Printf   (printf)\n\n(!) = index -- 强行把函数变成运算符\n\nmain :: IO ()\nmain = do\n    n &lt;- readLn :: IO Int -- 读取第一行的整数n，需要手动指定类型，不然会有歧义\n    fromList [fromList []] `foldM_'` [1..n] $ \\seq _ -&gt; do -- 函数的中缀用法，注意初始的历史记录应该有一个空串\n        [[op],c] &lt;- words &lt;$&gt; getLine -- 读取每一行的指令，此处使用了模式匹配（见下文）\n        case op of\n            'T' -&gt; pure $ (seq!0 |&gt; head c) &lt;| seq  -- 历史记录第0号（即上一次修改的结果）后插入当前字符，然后前插入历史记录\n            'U' -&gt; pure $ (seq!read c) &lt;| seq -- 将参数读取为整数（此处无需标明，因为函数有明确的类型限制，编译器将自动推导） 取历史记录的相应项，前插入历史记录\n            'Q' -&gt; printf \"%c\\n\" (seq!0!(read c-1))  $&gt; seq -- 将上一次修改的结果的相应位置的字符打印出来，并返回本身的历史记录（($ &gt;)运算符特性）\n\nfoldM_' z l f = foldM_ f z l -- 调整参数位置，追求好用\n代码十分朴素。\n\n空间复杂度:  ，其中\n\n为总字符数（不是很紧确，但是..能过）\n每次从后面添加字符，时间复杂度: \n每次打印第 \n个字符，时间复杂度:  ，其中 \n为当前字符数， \n为需要打印的字符位置。\n每次撤销，时间复杂度:  ，其中 \n为总修改次数， 为撤销步数。\n总时间复杂度可估算为: \n\n如果想看 FingerTree 原理或者希望以此为契机了解一下\nHaskell 的话参见后文。也可以参考论文原文。\n参考文献：\n\nHinze R, Paterson R. Finger trees: a simple general-purpose data\nstructure[J]. Journal of functional programming, 2006, 16(2):\n197-217.\nhttps://hackage.haskell.org/package/fingertree\nhttps://hackage.haskell.org/package/container\nhttps://wiki.haskell.org/Functional_dependencies\n\nFingerTree概述\n说到可持久化，就得想到 Immutable ，说到 Immutable\n，自然而然就是函数式编程语言，说到函数式编程语言，自然而然就是\nHaskell ，而说到纯函数式的数据结构，自然而然也绕不开\nFingerTree 。\nFingerTree\n是一种理论上非常通用也非常高效的数据结构，插入头/尾都只需要摊还  的时间， 而对其的“随机”访问只需要\n &gt; 其中 \n为你访问的下标，所以可以看出访问头/尾其实也是  。\n关于它的论文可以戳这里。当然这不是最早的一篇，但我看的就是这篇，才疏学浅没办法在这里列更早的。\n但为什么说“理论”上呢，就和斐波那契堆类似，他的常数比较大。（主要因素是Immutable的语言必须维护一个GC来做垃圾回收。）\n\n\n\n\n\n\n\n\n\n[更新] 事后我拿 Rust 实现了一遍 FingerTree\n，发现其时空消耗均比 Haskell 大，故可认为并非GC原因。\n不过也有可能是我写的常数就是大呢（\n详见：提交记录\n那为什么说“随机”呢？因为完全泛化的 FingerTree\n的访问依赖的不是下标，而是一个被称作 \n（测度？我也不知道怎么翻译，所以直接拉的原文）的幺半群\n(Monoid)。\n\n\n\n\n\n\n\n\n\n先解释一下什么是幺半群。幺半群是一个集合  和集合里元素之间一个二元运算 \n的统称（有序对），并要求：\n\n二元运算满足结合率，即 \n集合  中存在一个单位元，即\n\n\n比如说自然数集 \n与其上的加法 \n便可以构成一个幺半群（后面我们可以用这条性质做出传统意义上的下标索引）\n进一步，我们可以定义两个幺半群的笛卡尔积也是一个幺半群，即对于  与  ， 我们可以定义一个运算  ，并使其满足结合率。定义方法如下：\n\n\n\n我们可以用这个条件来拓展我们索引方式（比如论文原文里可以看到用  幺半群实现的最大堆/优先队列）\nHaskell基础\n首先，用 Haskell\n的方式定义一下幺半群（实际上这个标准库有，不需要自己实现）\nclass Monoid a where\n    mempty :: a\n    mappend :: a -&gt; a -&gt; a\n与常用的C-like语言中的 class 不同，在\nHaskell 中，这代表一个类型类，是对类型 a\n的一种约束，类似于接口/抽象类一类的概念。\n然后是 Foldable ，它代表我们可以在一个类型(其实是一个\nKind\n，拿类型生成类型的类型构造子)上按照某种顺序去遍历。类似于\nJava 8 中的 reduce\n。注意这个其实标准库也有，只是提一嘴。\nclass Foldable f where\n    foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b\n    foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b\n还需要提一嘴的是 Haskell\n最基本的数据结构，链表(实际上还是单端链表，所以只提供最基本的功能)。\ndata [] a = [] | a:([] a)\n它意味着一个 \n类型的链表有两种构造方式，一种是空链表，令一种是一个  类型的元素用 :\n运算符拼接一个 \n类型的链表。（对，中缀构造函数， C++ 是做不到这点的。）\n另外还有一个比较常用的 data 被称作 Maybe\n，它的定义等价于：\ndata Maybe a = Nothing | Just a\n想一想，这个定义是什么意思？\n从这里开始就可以看到 Haskell\n的一些特性了。Haskell\n中的数据结构并非由字段和操作构成，而是由几类数据的组合组合而成。当然它是可以实现上面的俩\nclass 的。这里我不做过多介绍。\nFingerTree\n实现（简要复述论文）\n\n\nFingerTree 概要图\n\n首先是一些基础定义。\n-- | Things that can be measured.\nclass (Monoid v) =&gt; Measured v a | a -&gt; v where\n    measure :: a -&gt; v\n\ndata Node v a = Node2 v a a | Node3 v a a a\ndata Digit a\n    = One a\n    | Two a a\n    | Three a a a\n    | Four a a a a\ndata FingerTree v a\n     = Empty\n     | Single a\n     | Deep v (Digit a) (FingerTree v (Node v a)) (Digit a)\n这里开始出现了最开始提到的\nMeasured，此处将其抽象为一个可以将某个元素测量出一个\nMonoid 的函数。但这个 Monoid 有大用。\n此处出现的语法使用了一个 Functional Dependencies\n的拓展(可参见 wiki\n)。大概意思是保证对于一个类型，我只能把它 measure\n成一种其他类型，不能 measure 成另一种。也就是说，类型\na 到类型 v 是一个单射。\n可以看到这里的 \n类型变元，这个就是稍后要维护的\nMonoid，也是索引数据的依据。\n可以看到一个 Node 可能有2-3个元素，保证一个\nDigit 有 1-4\n个元素。(图中也可以看出，不过引用链接是国外的可能比较卡)\nDigit 和 Node\n也可以相互转化，拼接，但后文不再说明实现。\n还有一点值得注意的是，如果当前这一层的 FingerTree\n缓存的是 a 类型的话，那么下一层所缓存的就是\nNode a 类型了。这也就意味着，下层比上层“厚实”。\n自然地，我们可以给 Node 和 Digit 来个\nFoldable，但具体部分就不展示了。\n那么我们应该如何方便的维护这个 \n类型的数据呢，答案是换一种方式重写构造函数。\ndeep ::  (Measured v a) =&gt;\n      Digit a -&gt; FingerTree v (Node v a) -&gt; Digit a -&gt; FingerTree v a\n deep pr m sf = Deep ((measure pr `mappend` measure m) `mappend` measure sf) pr m sf\n此处的 mappend 是 Haskell\n里函数的中缀用法（就是把函数当运算符用）。\n此时，我们不需要每次构造树的时候手动维护  类型的数据了，只需要简单把\nDeep 替换为 deep 即可。\n另外，关于 Measured 本身，我们也可以让\nFingerTree 也是 Measured，具体代码如下：\ninstance (Measured v a) =&gt; Measured v (FingerTree v a) where\n      measure Empty           =  mempty\n      measure (Single x)      =  measure x\n      measure (Deep v _ _ _)  =  v\n注意到此处使用了 Haskell 被称作模式匹配\n(Pattern\nMatch)的特性。（不是模式串匹配啦）把数据结构重新打回了它最开始定义时的样子，并且怎么被构造的就怎么被匹配。(真-打回娘胎)\n\n\n\n\n\n\n\n\n\n模式匹配不止可以匹配一层，也可以匹配多层。至于用途嘛..请自行搜索\nHaskell 的 20 行红黑树。\n可以看到对于 Deep 一类，我们直接使用了其缓存的  类型字段，这样就可以在 \n时间内得到一颗子树的测度。(如果对单个元素的 measure 也是\n 的话)\n当然 Node 和 Digit 也可以是\nMeasured，具体实现请自行脑补。\n接下来是前插入的定义。\ninfixr 5 &lt;|\n-- | /O(1)/. Add an element to the left end of a sequence.\n-- Mnemonic: a triangle with the single element at the pointy end.\n(&lt;|) :: Measured v a =&gt; a -&gt; FingerTree v a -&gt; FingerTree v a\na &lt;| Empty              =  Single a\na &lt;| Single b           =  deep (One a) Empty (One b)\na &lt;| Deep v (Four b c d e) m sf\n    = Deep (measure a `mappend` v) (Two a b) (node3 c d e &lt;| m) sf\na &lt;| Deep v pr m sf     = Deep (measure a `mappend` v) (consDigit a pr) m sf\n注意到这里我们自定义了一个运算符，它的优先级是5,并且是右结合的。（不愧是\nHaskell，轻易做到了 C++ 做不到的事情。）\nconsDigit 就是给 pr\n前插入一个元素。当然，如果是满的肯定会报错，但是在它之前的模式匹配会避免这一点发生。\n类似地还有后插入\ninfixl 5 .\n-- | /O(1)/. Add an element to the right end of a sequence.\n-- Mnemonic: a triangle with the single element at the pointy end.\n(|&gt;) :: (Measured v a) =&gt; FingerTree v a -&gt; a -&gt; FingerTree v a\nEmpty |&gt; a              =  Single a\nSingle a |&gt; b           =  deep (One a) Empty (One b)\nDeep v pr m (Four a b c d) |&gt; e\n    = Deep (v `mappend` measure e) pr (m |&gt; node3 a b c) (Two d e)\nDeep v pr m sf |&gt; x     = Deep (v `mappend` measure x) pr m (snocDigit sf x)\n可以看到代码基本上和前插入是对称的。（数据结构本身也是对称的，所以这里写作\nsnocDigit，其中 snoc 正是 cons\n的回文）后面还有很多对称的结构，均以左半部分为例。\n然后是一个分割原语（当然右侧也是对称的，可以看到又出现了运算符构造子。）\n-- | View of the left end of a sequence.\ndata ViewL s a\n     = EmptyL        -- ^ empty sequence\n     | a :&lt; s a      -- ^ leftmost element and the rest of the sequence\n\n-- | /O(1)/. Analyse the left end of a sequence.\nviewl :: (Measured v a) =&gt; FingerTree v a -&gt; ViewL (FingerTree v) a\nviewl Empty                     =  EmptyL\nviewl (Single x)                =  x :&lt; Empty\nviewl (Deep _ (One x) m sf)     =  x :&lt; rotL m sf\nviewl (Deep _ pr m sf)          =  lheadDigit pr :&lt; deep (ltailDigit pr) m sf\n\nrotL :: (Measured v a) =&gt; FingerTree v (Node v a) -&gt; Digit a -&gt; FingerTree v a\nrotL m sf      =   case viewl m of\n    EmptyL  -&gt;  digitToTree sf\n    a :&lt; m' -&gt;  Deep (measure m `mappend` measure sf) (nodeToDigit a) m' sf\nlheadDigit 和 ltailDigit 是指一个\nDigit 的最左边元素和剩下的元素，当然如果 Digit\n只有一个元素的画 ltail\n就会报错，但是前面的模式匹配也避免了这一点。\ndigitToTree 是一个将 Digit 变为一个\nFingerTree 的函数，因为也就常数个元素，所以时间复杂度 。\nnodeToDigit 也是跟名字异样，将一个\nNode(2或3个元素)变成一个 Digit。\ncase ... of 语法是 Haskell 类似于\nC++ 的 switch\n语句的地方。不同之处在于其是有返回值的，更像一个多出口的 ?:\n运算符。\nviewl\n函数构造一颗树的左分割，将其切割出最左元素（若没有则用\nEmptyL 构造子）。\n另外值得注意的是此处的 viewl 和 rotL\n是互相调用，也是一种递归哦。\n当然其有对称实现 viewr。但不在此赘述。\n有了 viewl 之后，我们就可以处理一些 prefix\n(即 Deep 中第一个\nDigit)为空/不存在时对树的构造了\ndeepL :: (Measured v a) =&gt;\n    Maybe (Digit a) -&gt; FingerTree v (Node v a) -&gt; Digit a -&gt; FingerTree v a\ndeepL Nothing m sf      =   rotL m sf\ndeepL (Just pr) m sf    =   deep pr m sf\n此处的 Nothing 就是指 prefix\n不存在的情况，此时需要左旋一波。\n当然对于 Just 的情况就直接调用上面的deep了。\n那么什么情况下左边/右边为空呢？当然是做分割的时候了。\n那么终于，要迎来最后的部分了，搜索，与分割。\ndata Split t a = Split t a t\ndata SearchResult v a\n    = Position (FingerTree v a) a (FingerTree v a)\n        -- ^ A tree opened at a particular element: the prefix to the\n       -- left, the element, and the suffix to the right.\n   | OnLeft\n       -- ^ A position to the left of the sequence, indicating that the\n       -- predicate is 'True' at both ends.\n   | OnRight\n       -- ^ A position to the right of the sequence, indicating that the\n       -- predicate is 'False' at both ends.\n   | Nowhere\n       -- ^ No position in the tree, returned if the predicate is 'True'\n       -- at the left end and 'False' at the right end.  This will not\n       -- occur if the predicate in monotonic on the tree.\n\nsearch :: (Measured v a) =&gt;\n    (v -&gt; v -&gt; Bool) -&gt; FingerTree v a -&gt; SearchResult v a\nsearch p t\n  | p_left &amp;&amp; p_right = OnLeft\n  | not p_left &amp;&amp; p_right = case searchTree p mempty t mempty of\n         Split l x r -&gt; Position l x r\n  | not p_left &amp;&amp; not p_right = OnRight\n  | otherwise = Nowhere\n   where\n     p_left = p mempty vt\n     p_right = p vt mempty\n     vt = measure t\n\nsearchTree :: (Measured v a) =&gt;\n     (v -&gt; v -&gt; Bool) -&gt; v -&gt; FingerTree v a -&gt; v -&gt; Split (FingerTree v a) a\nsearchTree _ _ Empty _ = illegal_argument \"searchTree\"\nsearchTree _ _ (Single x) _ = Split Empty x Empty\nsearchTree p vl (Deep _ pr m sf) vr\n  | p vlp vmsr  =  let  Split l x r     =  searchDigit p vl pr vmsr\n                   in   Split (maybe Empty digitToTree l) x (deepL r m sf)\n  | p vlpm vsr  =  let  Split ml xs mr  =  searchTree p vlp m vsr\n                        Split l x r     =  searchNode p (vlp `mappend` measure ml)       xs (measure mr `mappend` vsr)\n                   in   Split (deepR pr  ml l) x (deepL r mr sf)\n  | otherwise   =  let  Split l x r     =  searchDigit p vlpm sf vr\n                   in   Split (deepR pr  m  l) x (maybe Empty digitToTree r)\n  where\n    vlp     =  vl `mappend` measure pr\n    vlpm    =  vlp `mappend` vm\n    vmsr    =  vm `mappend` vsr\n    vsr     =  measure sf `mappend` vr\n    vm      =  measure m\n此处只列出了 searchTree 这一子函数，且十分冗长，其实\nsearchNode 和 searchDigit\n也类似，本质上就是为了找到第一个使得对于输入的函数，在值左边的分割为假，右边的为真。一步步细化下去而已。\nmaybe 函数的类型是\nb -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b，看类型签名基本可以猜到功能。所以也不细说。\n这里可以看到 where 从句。where\n从句和常量定义很像，但却是后置的，而且具有惰性求值的特征（对，自带Lazy，而且实际上如果不做额外标注，整个\nHaskell 程序都是惰性求值的）。\n到这一步为止，我们只差将原本用于索引的下标整成 Monoid\n就好了，并且其和任意类型均可以构成\nMeasured（因为单个元素大小都是1）\nnewtype Size = Size Int\nnewtype Elem a = Elem a\ninstance Monoid Size where\n\tmempty = Size 0\n\tmappend (Size a) (Size b) = Size (a+b)\ninstance Measured Size (Elem a) where\n\tmeasure _ = Size 1\n这里注意，由于我们之前使用了\nFunctional Dependencies，所以我们需要新建一个类型作为容器来容纳我们的类型。所以此处使用了不会导致额外开销的\nnewtype 关键字替代\ndata（在当前环境下，二者语义一致）\n接下来就可以实现 Seq 了，具体可以参考\ncontainer 包的源代码或者论文原文。\n","slug":"洛谷-P1383-高级打字机","date":"2020-05-19T16:23:53.000Z","categories_index":"Online Judge,洛谷","tags_index":"数据结构,算法","author_index":"zLeoAlex"},{"id":"fca4b626abe8dd9b0f5154dab7961f0c","title":"Raspberry PI 3B+刷OpenWRT坑点笔记","content":"刷写系统环节\n\nRPI3B和RPI3B+用的同一款固件，可以通用\n用个稍微好一点点的读卡器吧，毕竟也有几百M\n\n\n\n\n\n\n\n\n\n我Surface上的读卡器插两次就扫不到设备了，十分蛇皮\nUSB 读卡器又有点点接触不良，刷个几百k就一个读写错误，心累.jpg\n如果希望能完全使用TF卡的空间，单纯的resize分区是不行的，还要记得fsck然后跑一遍resize2fs\n&gt; 不知道为什么我先配完系统之后改大小然后就崩了。 &gt; &gt;\n但是如果在第一次启动前把分区大小调好就没事。\nWiFi的启用需要等到第一次启动以后，第一次启动的时候会生成配置文件，之后改改就好\n如果需要用USB to TTL之类的操作连接PI，那么还要改config.txt，没改成功过，不细说\n\n配置环节\n\n信道填自动就搜不到WiFi了不知道咋回事儿\n\n802.11ac的52-64信道在国内要求DFS/TPC(动态频率选择和传输功率控制)，可能是因为树莓派并没有相应的功能还往这几个信道上挤导致的。\n\nwan的接口名一定要小写，一定要小写，一定要小写，或者手动修改为防火墙wan区域\n刚配好时opkg镜像不能用https，只能走http，因为里面套件还不全\n\n网络配置\n多拨\n\n使用mwan3插件\n前面接个AP模式的路由器\n使用ip link add link eth0 name vethX type macvlan来添加虚拟网口\n其中留一个虚拟网口接br-lan接口，其余每个一个PPPoE接口\n设置mwan3的时候一定要填测试IP，让相应的策略能自动开启\n\n","slug":"RPI3B-OpenWrt坑点","date":"2020-05-10T16:24:30.000Z","categories_index":"网络","tags_index":"Raspberry PI,OpenWRT","author_index":"zLeoAlex"}]